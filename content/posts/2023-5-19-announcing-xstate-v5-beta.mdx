---
title: Announcing XState v5 beta
description: We’re excited to announce the beta release of XState v5 and related packages after many years of development.
tags:
  - xstate
  - xstate v5
  - announcement
  - beta
author:
  - David Khourshid
slug: announcing-xstate-v5-beta
ogImage: "https://stately.ai/blog/2023-05-19-announcing-xstate-v5-beta.png"
publishedAt: 2023-5-19
---

We’re excited to announce the beta release of XState v5 and related packages after many years of development. XState v4 is a powerful, fully open-source (MIT-licensed) and zero-dependency state management & orchestration solution based on state machines, statecharts, and the actor model. It is currently being used in production by many companies in the frontend and backend of many applications. Over the last few years, we have gathered lots of valuable feedback from the community on features they would like to see and better ways to gradually adopt XState in their team and lessen the learning curve.

You can try out XState v5 beta today by installing `xstate@beta`:

```bash
yarn add xstate@beta
```

We have added many new features and improvements that address these desires, so let’s dive in!

## Actor-first approach for any logic

Actors are now first-class citizens. In v4, you could invoke/spawn promises, callbacks, observables, and other state machines, but these were special-cased, and you could only `interpret()` machines. In v5, you can invoke/spawn _anything_; actors can be created from any type of logic, and any type of logic can be interpreted:

(Promise example)

The composable building block to this is “actor logic,” which is an object consisting of `.transition(...)` and `.getInitialState(...)` methods, among other useful properties and methods. XState v5 beta provides the following actor logic creators:

- `createMachine(machineDef)`
- `fromTransition(fn, initialState)`
- `fromPromise(promiseFn)`
- `fromCallback(fn)`
- `fromObservable(observableFn)`
- `fromEventObservable(observableFn)`

With this new actor logic abstraction, it will now be possible to create your own actor logic for any use-case; imagine `fromWebSocket(...)` or `fromWebWorker(...)`. Furthermore, higher-order actor functions can be made that bring additional functionality to actors, such as `withUndoRedo(actorLogic)` or `withLocalStoragePersistence(actorLogic)`. We’re still writing docs and examples on these new patterns, so keep on the lookout for them.

## Deep persistence

Actor persistence is a pattern where the internal state of an actor can be persisted and restored at any time. This is useful for server-side or client-side use-cases. In XState v4, machines can invoke/spawn actors, but those child actors are not persisted.

In XState v5 beta, actors are now deeply (recursively) persisted. Invoked/spawn actors will be persisted, as well as actors invoked/spawned from those actors, and so on:

(example)

## Actor system

As actors can spawn other actors, which in turn can spawn other actors, these connected actors form a natural hierarchy. This collection of connected actors is known as an actor system.

In XState v5 beta, calling `interpret(...)` to create a root actor will also create an implicit actor system. This enables a key feature called the **receptionist pattern**, where actors can be registered and looked up by name. This is useful for actors that need to communicate with each other, but don’t necessarily know about each other.

(example)

## Actor input

Providing input data for machines in v4 was not easy. You had to either:

- Create a factory machine function that took in some input data and returned a machine with that input data in context.
- Create a new machine with `machine.withContext(...)` and pass the entire context with the input data inside. 

Since only the machine should initially determine `context`, this was not ideal, as it was possible to initialize a machine at some impossible state.

In XState v5 beta, you can now provide input data to machines by passing it as the second argument to `interpret(machine, { input })`:

(example)

Furthermore, this works for any actor logic, not just machines:

(example)

## Unified arguments

<Tweet id="1555175849569263618" />

The crowd has spoken. Most of you wanted a unified arguments object for all implementation functions. Implementation functions previously took multiple arguments, making it hard to remember which argument to use or awkward to ignore certain arguments. In XState v5 beta, all implementation functions now take a single unified argument object, which contains `context`, `event`, and other properties relevant to the implementation function:

(example)

## Self reference

In the unified argument object, there is a `self` property that references the actor itself. This enables new, flexible patterns for actor communication, as you can pass this `self` reference to other actors in events:

(example)

## Higher-order guards

In XState v4, guards were simple functions that returned `true` or `false`. To negate a guard or combine guards, you had to create a new guard, which resulted in duplication or redundant code. In XState v5 beta, you can now use higher-order guards, which are functions that take in guards (referenced and/or inline) and return a guard function. There are 3 built-in higher-order guard functions: `and([...guards])`, `or([...guards])`, and `not(guard)`:

(example)

These higher-order guards can be combined in many different ways to express any complex condition.

## Predictable events and actions

In XState v4, actions and events had nuanced default behavior: `assign(...)` actions were prioritized over other actions, which made action order less predictable. Additionally, events were _nullified_ when going through eventless transitions, making it difficult to reference data from the original event. The `predictableActionArguments: true` flag was a necessary workaround for this. In XState v5 beta, actions are always executed in order, and events are always preserved, even when going through eventless transitions. No need for flags ⛳️

## Partial event descriptors

Partial event descriptors, also known as _partial wildcards_, are a powerful new feature in XState v5 beta that makes it easier to handle groups of events. In XState v4, you could use wildcards to handle any event that wasn’t matched by any other transition, but you had to be careful not to handle events that you didn’t intend to handle accidentally. In XState v5 beta, you can use partial event descriptors to handle groups of events by placing a wildcard after the delimiter (`.*`), and you can be explicit about which events you want to handle:

```ts
const machine = createMachine({
  // ...
  on: {
    // Will handle any event that starts with "pointer.":
    // "pointer.down", "pointer.up", "pointer.move", etc.
    "pointer.*": {
      actions: "logPointerEvent",
    },
  },
});
```

## Examples

- TodoMVC

## Migration and breaking changes

As with any major version, there are some breaking changes. We’ve tried to keep these to a minimum, but some are necessary to make XState v5 beta as powerful and flexible as possible. [Read our current guide for migrating from XState v4 to v5 and the list of breaking changes](https://stately.ai/docs/xstate-v5/migration).

## In progress

Now that the XState v5 beta API is mostly stabilized, we are working on the following:

- Type safety is priority. We are working on using the latest TypeScript features to make XState v5 beta as type-safe as possible. This includes better type inference for as many parts of the machine as possible, such as `context`, events, guards, actions, finite state values, and more. For everything that is not possible to be inferred or specified, we are updating [XState Typegen](#todo) to generate accurate TypeScript types for your machines. And yes, we’re still figuring out typestates.
- The [XState VS Code extension](https://marketplace.visualstudio.com/items?itemName=statelyai.vscode-xstate) will be updated to support XState v5 beta.
- [Stately Studio](https://stately.ai/editor) will also be updated to support importing/exporting XState v5 machines, as well as provide visual tooling for the new features in XState v5 beta, such as machine input/output, partial events, higher-order guards, and more.
- We’re making the inspector protocol and `@xstate/inspect` much more flexible, to support XState v5 beta and beyond (even other state management libraries).

## Stately Studio

Speaking of Stately Studio, besides adding support for XState v5, we’re taking the “everything is an actor” support to heart. We will be building visual tooling for not just managing actor logic but also entire actor systems and the communication between actors. This will be a huge step forward for visualizing and debugging complex systems, and we’re excited to share more about this in the future.

(CTA)

## Conclusion

We hope you enjoy XState v5 beta! We’re excited to see what you build with it (I know everyone says this, but we truly mean it). If you have any questions, feel free to reach out to us on [Discord](https://discord.gg/xstate) or [Twitter](https://twitter.com/statelyai).
