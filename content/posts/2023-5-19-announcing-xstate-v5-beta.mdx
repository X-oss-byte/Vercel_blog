---
title: Announcing XState v5 beta
description: We’re excited to announce the beta release of XState v5 and related packages after many years of development.
tags:
  - xstate
  - xstate v5
  - announcement
  - beta
author:
  - David Khourshid
slug: announcing-xstate-v5-beta
ogImage: "https://stately.ai/blog/2023-05-19-announcing-xstate-v5-beta.png"
publishedAt: 2023-5-19
---

We’re excited to announce the beta release of XState v5 and related packages after many years of development. XState v4 is a powerful, fully open-source (MIT-licensed) and zero-dependency state management & orchestration solution based on state machines, statecharts, and the actor model. It is currently being used in production by many companies in the frontend and backend of many applications. Over the last few years, we have gathered lots of valuable feedback from the community on features they would like to see and better ways to gradually adopt XState in their team and lessen the learning curve.

You can try out XState v5 beta today by installing `xstate@beta`:

```bash
yarn add xstate@beta
```

We have added many new features and improvements that address these desires, so let’s dive in!

## Flattening the learning curve

One of the biggest items of feedback we've received about XState is that although it is powerful, there is a substantial learning curve. There are some ~~new~~ old concepts to learn with XState, such as the actor model, state machines, and statecharts. With these concepts comes new terminology. In XState v5 beta and [the documentation](https://stately.ai/docs/xstate-v5), we have made a concerted effort to make XState as approachable as possible, and to reduce the learning curve as much as possible. Here are some of the changes we’ve made:

- **Simplified terminology**. There shouldn't be multiple names for any of the concepts, so we have taken care to simplify terms wherever possible. The basic unit of abstraction in XState v5 beta is the **actor**, and we’ve removed some of the more confusing terms, such as “service” and “interpreter”. We've also renamed "compound states" to "parent states", "transient transitions" to "eventless transitions", "cond" to "guard", "internal" to "reenter", and more.
- **Reduced API surface area**. Some of the new features, such as [input](#actor-input), obviated the need for redundant features, such as `machine.withContext(...)`. We’ve also removed redundant functionality, such as `actor.onTransition(...)` in favor of `actor.subscribe(...)`. [See all the breaking changes](https://stately.ai/docs/xstate-v5/migration).
- **Examples, examples, examples**. We're adding many XState v5 beta examples [in the examples directory](https://github.com/statelyai/xstate/tree/next/examples) to help you get quickly understand how XState can help with your use-cases.
- **Interactive documentation**. We’re working on adding interactive examples to the documentation, so you can visualize the concepts as you learn them. (TODO: example docs page)
- **From zero to hello world as quickly as possible**. Our goal with XState v5 and the [updated documentation (work in progress)](https://stately.ai/docs/xstate-v5) is to make developers productive with XState _as quickly as possible_. A simple, complete counter example in XState looks like this:

```ts
import { createMachine, interpret, assign } from "xstate";

const counterMachine = createMachine({
  id: "counter",
  context: {
    count: 0,
  },
  on: {
    increment: {
      actions: assign({ count: ({ context }) => context.count + 1 }),
    },
    decrement: {
      actions: assign({ count: ({ context }) => context.count - 1 }),
    },
  },
});

const counterActor = interpret(counterMachine);
counterActor.subscribe((state) => console.log(state.context.count));
counterActor.start();

counterActor.send({ type: "inc" }); // logs 1
counterActor.send({ type: "inc" }); // logs 2
counterActor.send({ type: "dec" }); // logs 1
```

This kind of functionality already covers the vast majority of state management needs for most applications. But what if you want to use XState for more complex use-cases? XState v5 beta has you covered.

## Actor-first approach for any logic

Actors are now first-class citizens. In v4, you could invoke/spawn promises, callbacks, observables, and other state machines, but these were special-cased, and you could only `interpret()` machines. In v5, you can invoke/spawn _anything_; actors can be created from any type of logic, and any type of logic can be interpreted:

```ts
import { interpret, fromPromise } from "xstate";

const promiseActor = interpret(
  fromPromise(() => fetch("https://api.example.com/users"))
);
```

The composable building block to this is “actor logic,” which is an object consisting of `.transition(...)` and `.getInitialState(...)` methods, among other useful properties and methods. XState v5 beta provides the following actor logic creators:

- `createMachine(machineDef)`
- `fromTransition(fn, initialState)`
- `fromPromise(promiseFn)`
- `fromCallback(fn)`
- `fromObservable(observableFn)`
- `fromEventObservable(observableFn)`

With this new actor logic abstraction, it will now be possible to create your own actor logic for any use-case; imagine `fromWebSocket(...)` or `fromWebWorker(...)`. Furthermore, higher-order actor functions can be made that bring additional functionality to actors, such as `withUndoRedo(actorLogic)` or `withLocalStoragePersistence(actorLogic)`. We’re still writing docs and examples on these new patterns, so keep on the lookout for them.

## Deep persistence

Actor persistence is a pattern where the internal state of an actor can be persisted and restored at any time. This is useful for server-side or client-side use-cases. In XState v4, machines can invoke/spawn actors, but those child actors are not persisted.

In XState v5 beta, actors are now deeply (recursively) persisted. Invoked/spawned actors will be persisted, as well as actors invoked/spawned from those actors, and so on:

```ts
const machine = createMachine({
  invoke: {
    src: "counter",
    id: "someCounter",
  },
  // ...
});

const actor = interpret(machine);
actor.start();

// Deeply persist state
// Also persists the "someCounter" actor!
const persistedState = actor.getPersistedState();

// Restore state
const restoredActor = interpret(machine, {
  state: persistedState,
});

// Starts at recursively persisted state
restoredActor.start();
```

## Actor system

As actors can spawn other actors, which in turn can spawn other actors, these connected actors form a natural hierarchy. This collection of connected actors is known as an actor system.

In XState v5 beta, calling `interpret(...)` to create a root actor will also create an implicit actor system. This enables a key feature called the **receptionist pattern**, where actors can be registered and looked up by name. This is useful for actors that need to communicate with each other, but don’t necessarily know about each other.

For example, let's say you have a `shopMachine` that orchestrates the state of an online shop. If you want a notifier actor to be available to any machines spawned anywhere within the `shopMachine` system, you can register it by providing a `systemId`:

```ts
import { notifierMachine } from "../notifierMachine";
import { shippingMachine } from "../shippingMachine";

const shopMachine = createMachine({
  invoke: {
    src: notifierMachine,
    systemId: "notifier",
  },
  // ...
  states: {
    // ...
    shipping: {
      invoke: {
        src: shippingMachine,
      },
    },
  },
});

const shopActor = interpret(shopMachine);
shopActor.start();
```

Now, any actor within the `shopMachine` system can access the notifier actor by calling `actor.system.get("notifier")`:

```ts
const shippingMachine = createMachine({
  // ...
  on: {
    "address.updated": {
      actions: sendTo(({ system }) => system.get("notifier"), {
        type: "notify",
        message: "Shipping address updated",
      }),
    },
  },
});
```

## Actor input

Providing input data for machines in v4 was not easy. You had to either:

- Create a factory machine function that took in some input data and returned a machine with that input data in context.
- Create a new machine with `machine.withContext(...)` and pass the entire context with the input data inside.

Since only the machine should initially determine `context`, this was not ideal, as it was possible to initialize a machine at some impossible state.

In XState v5 beta, you can now provide input data to machines by passing it as the second argument to `interpret(machine, { input })`:

```ts
const greetingMachine = createMachine({
  context: ({ input }) => ({
    greeting: `Hello, ${input.name}!`,
  }),
});

const greetingActor = interpret(greetingMachine, {
  input: {
    name: "David",
  },
});
```

Furthermore, this works for any actor logic, not just machines:

```ts
const promiseLogic = fromPromise(({ input }) =>
  fetch(`https://api.example.com/users/${input.id}`).then((res) => res.json())
);

const promiseActor = interpret(promiseLogic, {
  input: {
    id: 42,
  },
});
```

## Unified arguments

<Tweet id="1555175849569263618" />

The crowd has spoken. Most of you wanted a unified arguments object for all implementation functions. Implementation functions previously took multiple arguments, making it hard to remember which argument to use or awkward to ignore certain arguments. In XState v5 beta, all implementation functions now take a single unified argument object, which contains `context`, `event`, and other properties relevant to the implementation function:

```ts
const machine = createMachine({
  context: {
    count: 0,
  },
  on: {
    increment: {
      // Single argument, instead of:
      // guard: (_, event) => ...
      guard: ({ event }) => !Number.isNaN(event.value),
      // Single argument, instead of:
      // actions: (context, event) => ...
      actions: ({ context, event }) => {
        console.log(context, event);
      },
    },
  },
});
```

## Self reference

In the unified argument object, there is a `self` property that references the actor itself. This enables new, flexible patterns for actor communication, as you can pass this `self` reference to other actors in events:

```ts
const pingMachine = createMachine({
  invoke: {
    src: "pong",
    id: "pong",
  },
  on: {
    ping: {
      actions: sendTo("pong", ({ self }) => ({ type: "ping", sender: self })),
    },
  },
});

// ...

const pongMachine = createMachine({
  on: {
    ping: {
      actions: sendTo(({ event }) => event.sender, { type: "pong" }),
    },
  },
});
```

## Higher-order guards

In XState v4, guards were simple functions that returned `true` or `false`. To negate a guard or combine guards, you had to create a new guard, which resulted in duplication or redundant code. In XState v5 beta, you can now use higher-order guards, which are functions that take in guards (referenced and/or inline) and return a guard function. There are 3 built-in higher-order guard functions: `and([...guards])`, `or([...guards])`, and `not(guard)`:

```ts
import { createMachine, and, not } from "xstate";

const userMachine = createMachine(
  {
    // ...
    on: {
      doSomething: {
        guard: and(["isAuthenticated", "isAdmin", not("isBanned")]),
      },
    },
  },
  {
    guards: {
      isAuthenticated: ({ context }) => context.user !== undefined,
      isAdmin: ({ context }) => context.user.role === "admin",
      isBanned: ({ context }) => context.user.status === "banned",
    },
  }
);
```

These higher-order guards can be combined in many different ways to express any complex condition.

## Predictable events and actions

In XState v4, actions and events had nuanced default behavior: `assign(...)` actions were prioritized over other actions, which made action order less predictable. Additionally, events were _nullified_ when going through eventless transitions, making it difficult to reference data from the original event. The `predictableActionArguments: true` flag was a necessary workaround for this. In XState v5 beta, actions are always executed in order, and events are always preserved, even when going through eventless transitions. No need for flags ⛳️

## Partial event descriptors

Partial event descriptors, also known as _partial wildcards_, are a powerful new feature in XState v5 beta that makes it easier to handle groups of events. In XState v4, you could use wildcards to handle any event that wasn’t matched by any other transition, but you had to be careful not to handle events that you didn’t intend to handle accidentally. In XState v5 beta, you can use partial event descriptors to handle groups of events by placing a wildcard after the delimiter (`.*`), and you can be explicit about which events you want to handle:

```ts
const machine = createMachine({
  // ...
  on: {
    // Will handle any event that starts with "pointer.":
    // "pointer.down", "pointer.up", "pointer.move", etc.
    "pointer.*": {
      actions: "logPointerEvent",
    },
  },
});
```

## Examples

[See the TodoMVC example with React, TypeScript, and XState v5 beta](https://discord.com/channels/795785288994652170/795785288994652174/1110179749269086360)

## Migration and breaking changes

As with any major version, there are some breaking changes. We’ve tried to keep these to a minimum, but some are necessary to make XState v5 beta as powerful and flexible as possible. [Read our current guide for migrating from XState v4 to v5 and the list of breaking changes](https://stately.ai/docs/xstate-v5/migration).

## In progress

XState v5 beta API is mostly stabilized, and there is still a lot of work to be done now that we've reached this milestone. We are working on the following:

- Type safety is a priority. We are working on using the latest TypeScript features to make XState v5 beta as type-safe as possible. This includes better type inference for as many parts of the machine as possible, such as `context`, events, guards, actions, finite state values, and more. For everything that cannot be inferred or specified, we are updating [XState Typegen](https://stately.ai/docs/xstate/typescript/typegen) to generate accurate TypeScript types for your machines. And yes, we’re still figuring out typestates.
- We will update the [XState VS Code extension](https://marketplace.visualstudio.com/items?itemName=statelyai.vscode-xstate) to support XState v5 beta.
- We will also update [Stately Studio](https://stately.ai/editor) to support importing/exporting XState v5 machines, and provide visual tooling for the new features in XState v5 beta, such as machine input/output, partial events, higher-order guards, and more.
- We’re making the inspector protocol and `@xstate/inspect` much more flexible to support XState v5 beta and beyond (even other state management libraries).

## Stately Studio

Speaking of Stately Studio, besides adding support for XState v5, we’re taking the “everything is an actor” support to heart. We will be building visual tooling for not just managing actor logic but also entire actor systems and the communication between actors. This will be a huge step forward for visualizing and debugging complex systems, and we’re excited to share more about this in the future.

(CTA)

## We hope you enjoy XState v5 beta!

We’re excited to see what you build with it (I know everyone says this, but we truly mean it). If you have any questions, feel free to reach out to us on [Discord](https://discord.gg/xstate) or [Twitter](https://twitter.com/statelyai).
