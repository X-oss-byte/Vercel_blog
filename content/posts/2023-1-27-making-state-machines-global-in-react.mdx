---
title: Making state machines global in React
description: Learn how to use the `createActorContext` function to make state machines global in React.
tags:
  - react
  - hook
  - tutorial
author:
  - David Khourshid
originalURL: ""
excerpt: ""
ogImage: "https://stately.ai/blog/2023-1-27-making-state-machines-global-in-react.png"
publishedAt: 2023-1-27
---

React developers often need to share state between components. While the `useMachine(...)` hook provides a convenient way to represent local state as a state machine, it’s not very feasible for shared or global state. Thankfully, `@xstate/react`’s `createActorContext(machine)` function, released in `@xstate/react@3.1.0`, is a convenient way to share state machines globally in any React application.

The `createActorContext(machine)` function returns a [React Context object](https://beta.reactjs.org/learn/passing-data-deeply-with-context) that interprets the machine and makes the actor (interpreted machine) available through React Context. The object returned from `createActorContext(...)` has helper methods for accessing state and the actor ref. It takes one argument, `machine`, which is a state machine from `createMachine(...)` or a function that lazily returns a machine.

[▶️ Stately Stream: Simple React todo app with `createActorContext`](https://www.youtube.com/watch?v=M6KjEogxfQE)

Here’s how you would create a React Context for the actor and provide it in app scope:

```tsx
// ./App.tsx
import { createActorContext } from "@xstate/react";
import { someMachine } from "../path/to/someMachine";

// Create a React Context for the actor
export const SomeMachineContext = createActorContext(someMachine);

// ...

function App() {
  return (
    // Provide the actor context in app scope
    <SomeMachineContext.Provider>
      <SomeComponent />
    </SomeMachineContext.Provider>
  );
}
```

To consume the actor in a component, you can use the `useActor()` hook to get the `state` and `send` function, or you can use `useSelector(selector, compare?)` hook to derive a specific value from the snapshot:

```tsx
// ./SomeComponent.tsx
import { SomeMachineContext } from "./App";

function SomeComponent() {
  // Read full snapshot and get `send` function from `useActor()`
  const [state, send] = SomeMachineContext.useActor();
  // Or derive a specific value from the snapshot with `useSelector()`
  const count = SomeMachineContext.useSelector((state) => state.context.count);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => send({ type: "INCREMENT" })}>Increment</button>
    </div>
  );
}
```

As a reminder, the `useSelector(...)` hook is better when you want to control rerenders, as it will only rerender when the selected state changes.

If you only need the `actorRef`, which is a reference to the invoked actor, you can use the `useActorRef()` hook:

```tsx
import { SomeMachineContext } from "../path/to/SomeMachineContext";

function SomeComponent() {
  const actorRef = SomeMachineContext.useActorRef();

  return (
    <div>
      <button onClick={() => actorRef.send({ type: "INCREMENT" })}>
        Increment
      </button>
    </div>
  );
}
```

Lastly, if you need to provide implementation details to the machine, such as `actions`, `guards`, or `delays`, you can provide a similar machine in the `machine={...}` prop on the `Provider` component:

```tsx
import { SomeMachineContext } from "../path/to/SomeMachineContext";
import { someMachine } from "../path/to/someMachine";

function SomeComponent() {
  return (
    <SomeMachineContext.Provider
      machine={() =>
        someMachine.withConfig({
          actions: {
            doSomething: (ctx, ev) => {
              // ...
            },
          },
        })
      }
    >
      <SomeOtherComponent />
    </SomeMachineContext.Provider>
  );
}
```

Remember to wrap the custom machine in a function so that it’s lazily evaluated only once.
