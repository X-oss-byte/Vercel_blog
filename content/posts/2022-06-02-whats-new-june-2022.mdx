---
title: "What’s new in June 2022?"
description: Updates to XState, @xstate/test and the Stately editor in the last month.
tags:
  - stately
  - xstate
  - announcement
  - release
  - lightmode
  - xstate test
author:
  - Laura Kalbag
publishedAt: "2022-06-02"
ogImage: "https://stately.ai/blog/2022-06-02-whats-new-june-2022.png"
---

We’ve had a busy month and have plenty to share with you this June!

## Another Stately update

In May, we welcomed three new people to the Stately team. Kevin Maes and Anders Mellson join us as engineers, and Nick Perich as our product designer. Watch all three of them introduce themselves in [our office hours live stream from May 20](https://youtu.be/4WwaSZ-ciRI?t=127).

## XState Test v1 alpha

Last week we released an alpha version of the XState Test package. XState Test helps you get maximum coverage with minimal code by generating your test paths from a state machine. Below are some of the significant changes. 

### `TestModel` and test paths

We simplified how paths and plans work in `TestModel`, including changing `getShortestPlans` and `getSimplePlans` to `getShortestPaths` and `getSimplePaths`. These functions now return an array of paths instead of an array of plans which contain paths.

We also added `getPaths`, which defaults to `getShortestPaths` and can be passed a `pathGenerator` to customize how paths are generated.

`getShortestPaths()` and `getPaths()` will now traverse all _transitions_ by default, not just all events.

Take the following machine as an example:

```ts
const machine = createTestMachine({
  initial: 'toggledOn',
  states: {
    toggledOn: {
      on: {
        TOGGLE: 'toggledOff'
      }
    },
    toggledOff: {
      on: {
        TOGGLE: 'toggledOn'
      }
    }
  }
});
```

In `@xstate/test` version 0.x, this would run the following path by default:

```txt
toggledOn → TOGGLE → toggledOff
```

This was because the path satisfies two conditions:

1. Covers all states
2. Covers all events

But the path isn’t a complete test because it doesn’t test if going from `toggledOff` to `toggledOn` works.

Now, we seek to cover all transitions by default, resulting in the following path:

```txt
toggledOn → TOGGLE → toggledOff → TOGGLE → toggledOn
```

We also moved `events` from `createTestModel` to `path.test`, which allows for easier usage of per-test mocks and per-test context.

Old structure:

```ts
const model = createTestModel(machine, {
  events: {}
});
```

New structure:

```ts
const paths = model.getPaths().forEach((path) => {
  path.test({
    events: {}
  });
});
  ```

And we added `states` to `path.test()`, which allows you to define your tests outside of your machine, keeping the machine itself easy to read:

  ```ts
  const paths = model.getPaths().forEach((path) => {
    path.test({
      states: {
        myState: () => {},
        'myState.deep': () => {}
      }
    });
  });
  ```

### Event cases

We moved event cases out of `events` and into their own attribute called `eventCases`:

  ```ts
  const model = createTestModel(machine, {
    eventCases: {
      CHOOSE_CURRENCY: [
        {
          currency: 'GBP'
        },
        {
          currency: 'USD'
        }
      ]
    }
  });

  model.getPaths().forEach((path) => {
    it(path.description, async () => {
      await path.test({
        events: {
          CHOOSE_CURRENCY: ({ event }) => {
            console.log(event.currency);
          }
        }
      });
    });
  });
  ```

`eventCases` will now always produce a new path instead of only creating a path for the first case that matches.

We also removed `.testCoverage()`, and instead made `getPlans`, `getShortestPlans` and `getSimplePlans` cover all states and transitions enabled by event cases by default.

### `createTestMachine` and `createTestModel`

We added `createTestMachine`, which provides a slimmed-down API for creating machines that removes these types from the config type signature.

We also added validation on `createTestModel` to ensure you don’t include invalid machine configuration in your test machine. Invalid machine configs include `invoke`, `after`, and any actions with a `delay`.

[Watch Matt demonstrate the power of model-based testing with XState Test in a short video on Twitter](https://twitter.com/statelyai/status/1531250605313892352). [Read the XState test tag release notes on GitHub](https://github.com/statelyai/xstate/releases/tag/%40xstate%2Ftest%401.0.0-alpha.0).

## XState v5 alpha

XState v5 is now in alpha after many months of work by Mateusz and David. V5 has many new features; below are some of the highlights.

### `createMachine()`

The `Machine()` function has been removed. Use the `createMachine()` function instead.

```diff
-import { Machine } from 'xstate';
+import { createMachine } from 'xstate';

-const machine = Machine({
+const machine = createMachine({
  // ...
});
```

### Assign actions

Assign actions via `assign()` will now be executed “in order” rather than automatically prioritized. Assign actions will be evaluated after previously defined actions are evaluated. Actions that read from `context` will have those intermediate values applied rather than the final resolved value of all `assign()` actions taken, which was the previous behavior.

The execution order shouldn’t change the behavior of most state machines. To maintain the previous behavior, ensure that `assign()` actions are defined before any other actions.

### Machine context

The machine's `context` is now restricted to an `object`. Using an object was the most common usage, but now the typings prevent `context` from being anything but an object:

```ts
const machine = createMachine({
  // This will produce the TS error:
  // "Type 'string' is not assignable to type 'object | undefined'"
  context: 'some string'
});
```

If `context` is `undefined`, it will now default to an empty object `{}`:

```ts
const machine = createMachine({
  // No context
});

machine.initialState.context;
// => {}
```

### Types

All generic types containing `TContext` and `TEvent` will now follow the same, consistent order:

1.  `TContext`
2.  `TEvent`
3.  … all other generic types, including `TStateSchema, `TTypestate\`, etc.

```diff
-const service = interpret<SomeCtx, SomeSchema, SomeEvent>(someMachine);
+const service = interpret<SomeCtx, SomeEvent, SomeSchema>(someMachine);
```

### Removed the context parameter from the machine’s transition method

We also removed the third parameter (context) from the Machine’s transition method. If you want to transition with a particular context value, you should create appropriate `State` using `State.from`. For example, instead of `machine.transition('green', 'TIMER', { elapsed: 100 })`, you should do the following: `machine.transition(State.from('green', { elapsed: 100 }), 'TIMER')`.

### Dev tools

We have simplified dev tools integration. Redux dev tools support is no longer the default, but you can include it from `xstate/devTools/redux`:

```js
import { interpret } from 'xstate';
import { createReduxDevTools } from 'xstate/devTools/redux';

const service = interpret(someMachine, {
    devTools: createReduxDevTools({
    // Redux Dev Tools options
    })
});
```

By default, dev tools are attached to the global `window.__xstate__` object:

```js
const service = interpret(someMachine, {
    devTools: true // attaches via window.__xstate__.register(service)
});
```

And creating your own custom dev tools adapter is a function that takes in the `service`:

```js
const myCustomDevTools = service => {
    console.log('Got a service!');

    service.subscribe(state => {
    // ...
    });
};

const service = interpret(someMachine, {
    devTools: myCustomDevTools
});
```

### Actions and guards

We have removed the `execute` option for an interpreted service. If you don’t want to execute actions, we recommend that you don’t hardcode implementation details into the base `machine` that will be interpreted. Instead, you should extend the machine’s `options.actions`. The interpreter will execute all actions according to SCXML semantics immediately upon transition by default.

The `in: ...` property for transitions has been removed and replaced with guards. We recommended you use `stateIn()` and `not(stateIn())` guard creators instead:

```diff
+ import { stateIn } from 'xstate/guards';

// ...
on: {
  SOME_EVENT: {
    target: 'somewhere',
-   in: '#someState'
+   cond: stateIn('#someState')
  }
}
// ...
```

XState v5 now has support for higher-level guards, which are guards that can compose other guards:

- `and([guard1, guard2, /* ... */])` returns `true` if _all_ guards evaluate to truthy, otherwise `false`
- `or([guard1, guard2, /* ... */])` returns `true` if _any_ guard evaluates to truthy, otherwise `false`
- `not(guard1)` returns `true` if a single guard evaluates to `false` otherwise, `true`

```js
import { and, or, not } from 'xstate/guards';

const someMachine = createMachine({
  // ...
  on: {
    EVENT: {
      target: 'somewhere',
      guard: and([
        'stringGuard',
        or([{ type: 'anotherGuard' }, not(() => false)])
      ])
    }
  }
});
```

Actions and guards that follow eventless transitions will now receive the event that triggered the transition instead of a "null" event (`{ type: '' }`), which no longer exists:

  ```js
  // ...
  states: {
    a: {
      on: {
        SOME_EVENT: 'b'
      }
    },
    b: {
      always: 'c'
    },
    c: {
      entry: [(_, event) => {
        // event.type is now "SOME_EVENT", not ""
      }]
    }
  }
  // ...
  ```

The `in: '...'` transition property can now be replaced with `stateIn(...)` and `stateNotIn(...)` guards, imported from `xstate/guards`:

```diff
import {
  createMachine,
+ stateIn
} from 'xstate/guards';

const machine = createMachine({
  // ...
  on: {
    SOME_EVENT: {
      target: 'anotherState',
-     in: '#someState',
+     cond: stateIn('#someState')
    }
  }
})
```

The `stateIn(...)` and `stateNotIn(...)` guards also can be used the same way as `state.matches(...)`:

```js
// ...
SOME_EVENT: {
  target: 'anotherState',
  cond: stateNotIn({ red: 'stop' })
}
```

We’ve renamed the `cond` property in transition config objects to `guard`. This is a breaking change. The change unifies terminology for guarded transitions and guard predicates which we previously called “cond” or “conditional” predicates:

```diff
someState: {
  on: {
    EVENT: {
      target: 'anotherState',
-     cond: 'isValid'
+     guard: 'isValid'
    }
  }
}
```

The interface for guard objects has changed. Notably, you should place all guard parameters in the `params` property of the guard object:

The following example is from [Custom Guards](https://xstate.js.org/docs/guides/guards.html#custom-guards):

```diff
-cond: {
+guard: {
- name: 'searchValid', // `name` property no longer used
  type: 'searchValid',
- minQueryLength: 3
+ params: {
+   minQueryLength: 3
+ }
}
```

### Eventless transitions

Eventless transitions must now be specified in the `always: { ... }` object and not in the `on: { ... }` object:

```diff
someState: {
  on: {
    // Will no longer work
-   '': { target: 'anotherState' }
  },
+ always: { target: 'anotherState' }
}
```

### History

We’ve removed the `state.history` property; this does not affect the machine “history” mechanism.

Storing the previous state should now be done explicitly:

```js
let previousState;

const service = interpret(someMachine)
  .onTransition(state => {
    // previousState represents the last state here

    // ...

    // update the previous state at the end
    previousState = state;
  })
  .start();
```

### Actors and services

The `services` option passed as the second argument to `createMachine(config, options)` has been renamed to `actors`. Each value in `actors` should be a function that takes in `context` and `event` and returns a behavior for an actor. The provided behavior creators are:

- `fromMachine`
- `fromPromise`
- `fromCallback`
- `fromObservable`
- `fromEventObservable`

```diff
import { createMachine } from 'xstate';
+import { fromPromise } from 'xstate/actors';

const machine = createMachine(
  {
    // ...
    invoke: {
      src: 'fetchFromAPI'
    }
  },
  {
-   services: {
+   actors: {
-     fetchFromAPI: (context, event) => {
+     fetchFromAPI: (context, event) => fromPromise(() => {
        // ... (return a promise)
      })
    }
  }
);
```

The following handlers have also been removed, as they are redundant and can all be accomplished with `.onTransition(...)` and/or `.subscribe(...)`:

- `service.onEvent()`
- `service.onSend()`
- `service.onChange()`

The `service.send(...)` method no longer returns the next state and is a `void` (fire-and-forget) function. We’ve removed the redundant `service.sender(...)` method; use `service.send(...)` instead.


### Activities

In another breaking change, we have removed activities. Since you could consider activities as invoked services, you can implement them as such. Activities are services that do not send any events back to the parent machine, nor do they receive any events other than a “stop” signal when the parent changes to a state where the activity is no longer active. You can model this the same way as a callback service.

### And so much more…

We also removed previously deprecated properties, added support for prefix wildcard event descriptors, and much more. Read all the release notes and in the [XState v5 tag release notes](https://github.com/statelyai/xstate/releases/tag/xstate%405.0.0-alpha.0).

## Light mode in the Stately visual editor

Nick and Anders got straight to work in their first week at Stately, creating light mode for the visual editor. We will keep improving both light mode and dark mode in the future, but we thought the initial designs were too good not to share with everyone!

![A dark mode light mode state machine in the Stately editor show in light mode.](./images/light-mode.png)

Toggle “Switch to light mode” in the editor’s menu to view the editor in light mode. Toggle “Switch to dark mode” to switch back to dark mode.

![A dark mode light mode state machine in the Stately editor show in dark mode.](./images/dark-mode.png)

## And there’s more to come!

Want to know more about what we’ve got planned? [Check out our Roadmap](https://xstate.js.org/docs/roadmap/). Got any feedback or want to suggest features? [Share your thoughts in the XState discussions](https://github.com/statelyai/xstate/discussions).

We’re also looking for your feedback on XState snippets, errors in XState, and more in our [Stately RFCs (Requests for comments)](https://github.com/statelyai/rfcs).