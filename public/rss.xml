<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Stately.ai engineering blog</title>
    <link>https://stately.ai/blog</link>
    <description>The official Stately.ai engineering blog</description>
    <lastBuildDate>Mon, 18 Oct 2021 18:31:23 GMT</lastBuildDate>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <generator>https://github.com/jpmonette/feed</generator>
    <language>en</language>
    <copyright>All rights reserved to Stately.ai</copyright>
    <item>
      <title>
        <![CDATA[How do you convince your teammates to use XState]]>
      </title>
      <link>https://stately.ai/blog/how-do-you-convince-your-teammates-to-use-xstate</link>
      <guid>https://stately.ai/blog/how-do-you-convince-your-teammates-to-use-xstate</guid>
      <pubDate>Mon, 11 Oct 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Last week our question of the week was how do you convince your teammates to use XState? Here are some suggestions.]]>
      </description>
      <content:encoded>
        <![CDATA[<p>Last week our question of the week was ‚Äú<em>how do you convince your teammates to use XState?</em>‚Äù</p><p>One of our most frequent requests for the documentation is more advice on how to convince others to use XState. Many people <a href="https://dev.to/mpocock1/how-to-manage-global-state-with-xstate-and-react-3if5">read an article</a>, <a href="https://www.youtube.com/watch?v=9k1ZHHJWt7k">watch a talk</a> or <a href="https://frontendmasters.com/courses/xstate/">participate in a workshop</a> about XState and are sold on using XState themselves. But when it comes to getting their team on board, they often need more.</p><p>Thanks to all the wonderful folks who answered our question <a href="https://twitter.com/statelyai/status/1446035499777462274">posted to Twitter</a> and in our #office-hours <a href="https://discord.gg/xstate">Discord</a> channel, we‚Äôve got some fantastic suggestions.</p><h2>Present using the Visualizer</h2><blockquote><p>‚ÄúI did a demo of the visualizer in front of devs and non-devs (ux designers and managers). They like the fact it gives the opportunity to discuss about features before jumping into coding‚Äù
<a href="https://twitter.com/seya_obey/status/1446237663535714304">Seya Obey‚Äôs tweet</a>.</p></blockquote><blockquote><p>‚ÄúI did a presentation showing the amazing power of xstate. Visualizer, Examples, Inspect for debugging and generate testing.‚Äù
<a href="https://twitter.com/ManorYanir/status/1446087845073113092">yanir manor‚Äôs tweet</a>.</p></blockquote><h2>Give examples using their own work</h2><p>Nick Hehr takes it step-by-step, utilizing the Visualizer.</p><blockquote><p>‚ÄúI start by demonstrating how visualizing a feature as a statechart can help understand the problem. Only once they‚Äôre on board with that premise would I start pointing to xstate for developing that statechart.‚Äù
<a href="https://twitter.com/hipsterbrown/status/1446092594338017280">Nick Hehr‚Äôs tweet</a>.</p></blockquote><blockquote><p>‚ÄúTake a part of the app they modeled, find out the bugs and solve them by remodeling it using a statechart. Then show them the visualization.‚Äù
<a href="https://twitter.com/farzad_yz/status/1446062078264020994">Farzad Yousefzadeh‚Äôs tweet</a>.</p></blockquote><p>And Farzad successfully convinced his team. We discussed his success in <a href="https://www.youtube.com/watch?v=GCWZ-froHKo">our office hours last week</a>.</p><h2>Give them side-by-side examples</h2><p>Amy Pellegrini recommended many complementary approaches, starting with comparing XState to other types of state management.</p><blockquote><p>‚ÄúMake a short experiment and compare with other tools (e.g. implement a feature in Xstate and Redux and see by yourself)‚Äù
<a href="https://twitter.com/amyvpellegrini/status/1446419479483793411">Amy Pellegrini‚Äôs tweet</a>.</p></blockquote><blockquote><p>‚ÄúUse the visualizer to model your system beforehand. Using state-machine tool will be a natural progression from that.‚Äù
<a href="https://twitter.com/amyvpellegrini/status/1446419828185645058">Amy Pellegrini‚Äôs second tweet</a>.</p></blockquote><h2>Show existing projects using XState</h2><p><a href="https://twitter.com/amyvpellegrini/status/1446420841219215372">https://twitter.com/amyvpellegrini/status/1446420841219215372</a></p><h2>Become the expert so you can answer their questions and help them progress</h2><p><a href="https://twitter.com/amyvpellegrini/status/1446421516334387203">https://twitter.com/amyvpellegrini/status/1446421516334387203</a></p><p><a href="https://twitter.com/norablindsided/status/1446152427187572738">https://twitter.com/norablindsided/status/1446152427187572738</a></p><h2>Dictate the use as team lead</h2><p><a href="https://discord.com/channels/795785288994652170/895591583586598943/895730595378913390">C√©dric</a>:</p><blockquote><p>I have said: &quot;We will use XState&quot; üòÇ</p></blockquote><p><a href="https://twitter.com/VanTanev/status/1446084841259274240">https://twitter.com/VanTanev/status/1446084841259274240</a></p><h2>Tell them how fast and responsive the Stately team is üòä</h2><p><a href="https://discord.com/channels/795785288994652170/895591583586598943/895738949635551273">C√©dric:</a></p><blockquote><p>Xstate team improve the project really quickly, office hours give a good idea of the roadmap and features, when something is propose there are a real discussion and project improvement from only &quot;an idea&quot; on discord</p></blockquote><h2>Promoting the collaboration benefits</h2><p><a href="https://discord.com/channels/795785288994652170/895591583586598943/895738949635551273">C√©dric</a>: </p><blockquote><ul><li>The Viz is a real support to share business logic between product and tech team, this could be add[ed] into a specifications and of course with the futur[e] way to create machine by a simple drag and drop this offer[s] the possibility for the product team to create themselves a real machine useful [for] the tech team</li></ul></blockquote><h2>Timing it right with a good use case for the team</h2><p><a href="https://discord.com/channels/795785288994652170/895591583586598943/895754626689814578">Jan</a>:</p><blockquote><p>I received the task to build some pretty complicated UI components, and I opted to build them with simple state machines, implemented as good ol&#x27; <code>switch</code>-based reducers. Since we&#x27;re using Redux, this approach didn&#x27;t alienate my team entirely, and so the seed had been planted.</p><p>Fast-forward a bit, and we&#x27;re currently rewriting some of the core of our application as a state machine (or something of a Frankenstein statechart), after receiving new requirements would make it completely unmaintainable if we had continued in the same tracks. We&#x27;re still doing it with <code>switch</code> (with nested states, even!), which isn&#x27;t optimal, but it&#x27;s way better than where we came from. </p><p>For now it does the job, but my plan is to note any pains which could easily be solved with XState, and propose a rewrite if/when the time is right. I figure it will be a much easier sell if my team is already somewhat familiar with the concepts of state machines, and we have a really good use-case on our hands.</p></blockquote><h2>Make them less intimidated by the terminology</h2><p><a href="https://twitter.com/james_womack/status/1446153971219853314">https://twitter.com/james_womack/status/1446153971219853314</a></p>]]>
      </content:encoded>
    </item>
    <item>
      <title>
        <![CDATA[Introduction to state machines and statecharts]]>
      </title>
      <link>https://stately.ai/blog/introduction-to-state-machines-and-statecharts</link>
      <guid>https://stately.ai/blog/introduction-to-state-machines-and-statecharts</guid>
      <pubDate>Sat, 02 Oct 2021 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Introduction to state machines and statecharts]]>
      </description>
      <content:encoded>
        <![CDATA[<p>Statecharts are a visual language used to describe the states in a process.</p><p>You may have used similar diagrams in the past to design user flows, plan databases or map app architecture. Statecharts are another way of using boxes and arrows to represent flows, but with XState these flows are also executable code that can be used to control the logic in your applications.</p><p>This guide covers the basics of statecharts in a beginner-friendly way, including:</p><ul><li><a href="#states">states</a></li><li><a href="#transitions-and-events">transitions and events</a></li><li><a href="#initial-state">initial states</a></li><li><a href="#final-state">final states</a></li><li><a href="#compound-states">compound states</a></li><li><a href="#parallel-states">parallel states</a></li><li><a href="#self-transition">self-transitions</a></li><li><a href="#planning-statecharts">planning statecharts</a></li><li><a href="#delayed-transitions">delayed transitions</a></li><li><a href="#actions">actions</a></li></ul><h2>States</h2><p>The <em>states</em> are represented by rounded rectangle boxes. To draw a statechart for the process of a dog, there are two states that would first come to mind:</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/asleep-awake.svg"/></p><p>A dog is always <strong>asleep</strong> or <strong>awake</strong>. The dog can‚Äôt be asleep and awake at the same time, and it‚Äôs impossible for the dog to be neither asleep nor awake. There‚Äôs only these two states, a precisely limited, <em>finite</em> number of states.</p><h2>Transitions and events</h2><p>How the dog goes between <strong>asleep</strong> and <strong>awake</strong> is through <em>transitions</em>, which are symbolised by an arrow pointing from one state to the next state in the process‚Äôs sequence.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/transitions-events.svg"/></p><p>A transition is caused by an <em>event</em> that results in the change of state. Transitions are labelled with their events.</p><p>Transitions and events are <em>deterministic</em>. Deterministic means that each transition and event always points to the same next state, and always produces the same result from their given starting condition, every time the process is run. Dogs never <strong>wake up</strong> to become <strong>asleep</strong> or <strong>fall asleep</strong> to become <strong>awake</strong>.</p><p>This tiny dog process, with its two finite states and two transitions is a <em>Finite State Machine.</em> A state machine is used to describe the behavior of something. The machine describes the thing‚Äôs states and the transitions between those states. It‚Äôs a Finite State Machine because it has a finite number of states. (Sometimes abbreviated to FSM by folks who love jargon).</p><h2>Initial state</h2><p>Any process that has states will have an <em>initial state</em>, the default state the process exists in until an event happens to change the process‚Äôs state.</p><p>The initial state is represented by a filled circle with an arrow pointing from the circle to the initial state.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/initial-state.svg"/></p><p>Using a statechart to describe the process of walking the dog, the initial state would be <strong>waiting</strong> to walk.</p><h2>Final state</h2><p>Most processes with states will have a <em>final state</em>, the last state when the process is finished. The final state is represented by a double border on the state‚Äôs rounded rectangle box.</p><p>In the dog walking statechart, the final state would be <strong>walk complete</strong>.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/final-state.svg" alt="Dog walking statechart showing waiting state transitioning through the leave home event to the on a walk state, then transitioning through the arrive home event to the final state of walk complete."/></p><h2>Compound states</h2><p>A compound state is a state that can contain more states, also known as child states. These child states can only happen when the parent compound state is happening. Inside the <strong>on a walk</strong> state, there could be the child states of <strong>walking</strong>, <strong>running</strong> and <strong>stopping to sniff good smells</strong>.</p><p>A compound state is symbolised by a labelled rounded rectangle box that acts as a container for its child states.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/compound-state.svg"/></p><p>A compound state should also specify which child state is the initial state. In the <strong>on a walk</strong> compound state, the initial state is <strong>walking</strong>.</p><p>Compound states are what makes statecharts capable of handling more complexity than an everyday state machine.</p><h3>Atomic states</h3><p>An atomic state is a state that doesn‚Äôt have any child states. <strong>Waiting</strong>, <strong>walk complete</strong>, <strong>walking</strong>, <strong>running</strong> and <strong>stopping to sniff good smells</strong> are all atomic states.</p><h3>Parallel states</h3><p>A parallel state is a compound state where all of its child states, also known as regions, are active simultaneously. The regions are separated inside the compound state container by a dashed line.</p><p>Inside the <strong>on a walk</strong> compound state, there could be two regions. One region contains the dog‚Äôs activity child states of <strong>walking</strong>, <strong>running</strong> and <strong>stopping to sniff good smells</strong>, and the other region containing the dog‚Äôs tail states of <strong>wagging</strong> and <strong>not wagging</strong>. The dog can walk and wag its tail, run and wag its tail or stop and sniff while wagging its tail, it can also do any of these activities without wagging its tail.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/parallel-states.svg"/></p><p>Both regions should also specify which child state is the initial state. In our <strong>tail</strong> region, the initial state is <strong>not wagging</strong>.</p><h3>Self-transition</h3><p>A self-transition is when an event happens, but the transition returns to the same state. The transition arrow exits and re-enters the same state.</p><p>A helpful way to describe a self-transition is ‚Äúdoing something, not going somewhere‚Äù in the process.</p><p>In a <strong>dog begging</strong> process, there would be a <strong>begging</strong> state with a <strong>gets treat</strong> event. And for the dogs who love their food, no matter how many times you go through the <strong>gets treat</strong> event, the dog returns to its <strong>begging</strong> state.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/self-transition.svg"/></p><h2>Planning statecharts</h2><p>One of the benefits of statecharts is that, in the process of putting a statechart together, you explore all the possible states in your process. This exploration will help you avoid bugs and errors in your code as you‚Äôre more likely to cover all the eventualities.</p><p>And because statecharts are executable, they can behave as both the diagram and the code, making it less likely that you‚Äôll introduce differences or bugs interpreting between the diagramming and coding environments.</p><h3>Planning a statechart for a login machine</h3><p>To draw a statechart for a login machine, start by listing the basic <em>events</em> in the process. Think about what your login process will <em>do</em>:</p><ul><li>log in</li><li>log out</li></ul><p>Then list the <em>states</em> that exist as a result of those events:</p><ul><li>logged in</li><li>logged out</li></ul><p>Once there‚Äôs some events and states, there‚Äôs the beginnings of a statechart.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/basic-login.svg" alt="Login statechart showing an initial logged out state transitioning through a log in event to a logged in state, then transitioning through a log out event back to the logged out state."/></p><p>Don‚Äôt forget the <em>initial state</em>. In this case, the <strong>logged out</strong> state is the initial state, as any new user would come to the process logged out.</p><h2>Delayed transitions</h2><p>Some login and logout processes will log out an inactive user after a fixed length of time as a security measure.</p><p>The <strong>active</strong> and <strong>idle</strong> states only happen when the user is logged in, so these become child states inside the <strong>logged in</strong> compound state.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/login-compound-state.svg"/></p><p>The initial state inside the <strong>logged in</strong> compound state is <strong>active</strong>, as it happens as a direct result of the <strong>log in</strong> event, and logging in is a sign of user activity.</p><p>A <em>delayed transition</em> is a type of transition which happens after being in a state for a specified length of time. The delayed transition is labelled with ‚Äúafter‚Äù and a fixed duration to indicate how much time should pass before transitioning to the next indicated state.</p><p>In the login statechart, a delayed transition of <strong>60000</strong> milliseconds, or 1 minute, follows the <strong>active</strong> state to determine whether the user is <strong>idle</strong>. If there is an <strong>activity</strong> event before the transition reaches one minute, the process returns to the <strong>active</strong> state.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/delayed-transition.svg"/></p><p>A delayed transition of <strong>180000</strong> milliseconds, or 3 minutes, follows the <strong>idle</strong> state to transition to the <strong>auto logged out</strong> state if the user remains idle.</p><h2>Actions</h2><p>A statechart is used to set off <em>actions</em> in the system outside of the statechart. Actions are also commonly known as <em>effects</em> or <em>side-effects</em>. ‚ÄúSide effects‚Äù sounds like a negative or unimportant term, but setting off actions is the primary purpose in using statecharts.</p><p>Actions are events that have no impact or consequences for the rest of the sequence, the event is just triggered and the sequence moves on to the next step in the process. For example, the login statechart might execute actions that change the user interface.</p><p>An <em>action</em> can be fired upon entering or exiting a state, or on a transition. An action on a state is included inside the state‚Äôs container with an ‚Äúentry /‚Äù or ‚Äúexit /‚Äù label depending on whether the action should be fired on entry or exit from the state.</p><p>In the login statechart, there‚Äôs an <em>entry</em> action on the <strong>idle</strong> state to warn the user that they may be logged out.</p><p><img src="https://raw.githubusercontent.com/statelyai/xstate/d98d948a534b028f4af8b271eb431a8625ab5cb3/docs/guides/introduction-to-state-machines-and-statecharts/entry-action.svg"/></p>]]>
      </content:encoded>
    </item>
    <item>
      <title>
        <![CDATA[How to manage global state with XState and React]]>
      </title>
      <link>https://stately.ai/blog/how-to-manage-global-state-with-xstate-and-react</link>
      <guid>https://stately.ai/blog/how-to-manage-global-state-with-xstate-and-react</guid>
      <pubDate>Thu, 27 May 2021 00:00:00 GMT</pubDate>
      <content:encoded>
        <![CDATA[<blockquote><p>This article has become part of the official <a href="https://xstate.js.org/docs/recipes/react.html">XState docs</a>!</p></blockquote><p>Many React applications follow the Flux architecture popularised by <a href="https://redux.js.org/">Redux</a>. This setup can be characterised by a few key ideas:</p><ol><li>It uses a single object at the top of your app which stores all application state, often called the <strong>store</strong>.</li><li>It provides a single <code>dispatch</code> function which can be used to send messages up to the store. Redux calls these <code>action</code>s, but I&#x27;ll be calling them <code>events</code> - as they&#x27;re known in XState.</li><li>How the store responds to these messages from the app are expressed in pure functions - most often in <strong>reducers</strong>.</li></ol><p>This article won&#x27;t go into depth on whether the Flux architecture is a good idea. David Khourshid&#x27;s article <a href="https://dev.to/davidkpiano/redux-is-half-of-a-pattern-1-2-1hd7">Redux is half a pattern</a> goes into great detail here. For the purposes of this article, we&#x27;re going to assume that you like having a global store, and you want to replicate it in XState.</p><p>There are many reasons for wanting to do so. XState is second-to-none when it comes to managing complex asynchronous behaviour and modelling difficult problems. Managing this in Redux apps usually involves middleware: either <a href="https://github.com/reduxjs/redux-thunk">redux-thunk</a>, <a href="https://github.com/redux-loop/redux-loop">redux-loop</a> or <a href="https://github.com/redux-saga/redux-saga">redux-saga</a>. Choosing XState gives you a first-class way to manage complexity.</p><h2>A globally available store</h2><p>To mimic Redux&#x27;s globally-available store, we&#x27;re going to use React context. React context can be a tricky tool to work with - if you pass in values which change too often, in can result in re-renders all the way down the tree. That means we need to pass in values which change as little as possible.</p><p>Luckily, XState gives us a first-class way to do that.</p><pre><code class="language-ts">import React, { createContext } from &quot;react&quot;;
import { useInterpret } from &quot;@xstate/react&quot;;
import { authMachine } from &quot;./authMachine&quot;;
import { ActorRefFrom } from &quot;xstate&quot;;

interface GlobalStateContextType {
  authService: ActorRefFrom&lt;typeof authMachine&gt;;
}

export const GlobalStateContext = createContext(
  // Typed this way to avoid TS errors,
  // looks odd I know
  {} as GlobalStateContextType
);

export const GlobalStateProvider = (props) =&gt; {
  const authService = useInterpret(authMachine);

  return (
    &lt;GlobalStateContext.Provider value={{ authService }}&gt;
      {props.children}
    &lt;/GlobalStateContext.Provider&gt;
  );
};
</code></pre><p>Using <code>useInterpret</code> returns a <code>service</code>, which is a static reference to the running machine which can be subscribed to. This value never changes, so we don&#x27;t need to worry about wasted re-renders.</p><h2>Utilising context</h2><p>Further down the tree, you can subscribe to the service like this:</p><pre><code class="language-ts">import React, { useContext } from &quot;react&quot;;
import { GlobalStateContext } from &quot;./globalState&quot;;
import { useActor } from &quot;@xstate/react&quot;;

export const SomeComponent = (props) =&gt; {
  const globalServices = useContext(GlobalStateContext);
  const [state] = useActor(globalServices.authService);

  return state.matches(&quot;loggedIn&quot;) ? &quot;Logged In&quot; : &quot;Logged Out&quot;;
};
</code></pre><p>The <code>useActor</code> hook listens for whenever the service changes, and updates the <code>state</code> value.</p><h2>Improving Performance</h2><p>There&#x27;s an issue with the implementation above - this will update the component for any change to the service. Redux offers tools for deriving state using selectors - functions which restrict which parts of the state can result in components re-rendering.</p><p>Luckily, XState provides that too.</p><pre><code class="language-ts">import React, { useContext } from &quot;react&quot;;
import { GlobalStateContext } from &quot;./globalState&quot;;
import { useSelector } from &quot;@xstate/react&quot;;

const selector = (state) =&gt; {
  return state.matches(&quot;loggedIn&quot;);
};

export const SomeComponent = (props) =&gt; {
  const globalServices = useContext(GlobalStateContext);
  const isLoggedIn = useSelector(globalServices.authService, selector);

  return isLoggedIn ? &quot;Logged In&quot; : &quot;Logged Out&quot;;
};
</code></pre><p>Now, this component will only re-render when <code>state.matches(&#x27;loggedIn&#x27;)</code> returns a different value. This is my recommended approach over <code>useActor</code> for when you want to optimise performance.
Dispatching events</p><p>For dispatching events to the global store, you can call a service&#x27;s send function directly.</p><pre><code class="language-ts">import React, { useContext } from &quot;react&quot;;
import { GlobalStateContext } from &quot;./globalState&quot;;

export const SomeComponent = (props) =&gt; {
  const globalServices = useContext(GlobalStateContext);

  return (
    &lt;button onClick={() =&gt; globalServices.authService.send(&quot;LOG_OUT&quot;)}&gt;
      Log Out
    &lt;/button&gt;
  );
};
</code></pre><p>Note that you don&#x27;t need to call useActor for this, it&#x27;s available right on the context.</p><h2>Deviations from Flux</h2><p>Keen-eyed readers may spot that this implementation is slightly different from Flux. For instance - instead of a single global store, one might have several running machines at once: <code>authService</code>, <code>dataCacheService</code>, and <code>globalTimeoutService</code>. Each of them have their own <code>send</code> attributes, too - so you&#x27;re not calling a global dispatch.</p><p>These changes can be worked around. One could create a synthetic send inside the global store which called all the services&#x27; <code>send</code> function manually. But personally, I prefer knowing exactly which services my messages are being passed to, and it avoids having to keep events globally namespaced.</p><h2>Summary</h2><p>XState can work beautifully as a global store for a React application. It keeps application logic co-located, treats side effects as first-class citizens, and offers good performance with <code>useSelector</code>. You should choose this approach if you&#x27;re keen on the Flux architecture but feel your app&#x27;s logic is getting out of hand.</p>]]>
      </content:encoded>
    </item>
    <item>
      <title>
        <![CDATA[State Management: How to tell a bad boolean from a good boolean]]>
      </title>
      <link>https://stately.ai/blog/state-management-how-to-tell-a-bad-boolean-from-a-good-boolean</link>
      <guid>https://stately.ai/blog/state-management-how-to-tell-a-bad-boolean-from-a-good-boolean</guid>
      <pubDate>Wed, 27 May 2020 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[TL;DR: Bad booleans represent state. Good booleans are derived from state]]>
      </description>
      <content:encoded>
        <![CDATA[<p><strong>TL;DR</strong>: Bad booleans represent state. Good booleans are derived from state.</p><p>When you&#x27;re managing state in your app, it&#x27;s easy to fall prey to bad booleans. Bad booleans look like this:</p><pre><code class="language-js">let isLoading = true;
let isComplete = false;
let hasErrored = false;
</code></pre><p>On the surface, this looks like good code. It appears as though you&#x27;ve represented three separate states with proper boolean names. In the &#x27;model&#x27; you&#x27;ve pictured for your state, only one of these states can be true at any one time.</p><p>In a fetch request, you might model the state like this:</p><pre><code class="language-js">const makeFetch = async () =&gt; {
  isLoading = true;
  try {
    await fetch(&quot;/users&quot;);

    isComplete = true;
  } catch (e) {
    hasErrored = true;
  }
  isLoading = false;
};
</code></pre><p>Again, this looks nice. We&#x27;re orchestrating our booleans as we move through the async request.</p><p>But there&#x27;s a bug here. What happens if we make the fetch, it succeeds, and we make the fetch again? We&#x27;ll end up with:</p><pre><code class="language-js">let isLoading = true;
let isComplete = true;
let hasErrored = false;
</code></pre><h2>Implicit states</h2><p>You probably hadn&#x27;t considered this when you made your initial model. You may have frontend components which are checking for <code>isComplete === </code> true or <code>isLoading === true</code>. You might end up with a loading spinner and the previous data showing at the same time.</p><p>How is this possible? Well, you&#x27;ve created some implicit states. Let&#x27;s imagine you considered 3 states as ones you actually wanted to handle:</p><ol><li><code>loading</code>: Loading the data</li><li><code>complete</code>: Showing the data</li><li><code>errored</code>: Erroring if the data doesn&#x27;t turn up</li></ol><p>Well, you&#x27;ve actually allowed 8 states! That&#x27;s 2 for the first boolean, times 2 for the second, times 2 for the third.</p><p>This is what&#x27;s known as boolean explosion - I learned about this from [https://egghead.io/lessons/javascript-eliminate-boolean-explosion-by-enumerating-states](Kyle Shevlin&#x27;s egghead course).</p><h2>Making states explicit</h2><p>How do you get around this? Instead of a system with 8 possible values, we need a system with three possible values. We can do this in Typescript with an enum.</p><pre><code class="language-ts">type Status = &quot;loading&quot; | &quot;complete&quot; | &quot;errored&quot;;

let status: Status = &quot;loading&quot;;
</code></pre><p>We&#x27;d implement this in a fetch like this:</p><pre><code class="language-ts">const makeFetch = async () =&gt; {
  status = &quot;loading&quot;;
  try {
    await fetch(&quot;/users&quot;);

    status = &quot;complete&quot;;
  } catch (e) {
    status = &quot;errored&quot;;
  }
};
</code></pre><p>It&#x27;s now impossible to be in the &#x27;loading&#x27; and &#x27;complete&#x27; state at once - we&#x27;ve fixed our bug. We&#x27;ve turned our bad booleans into a good enum.</p><h2>Making good booleans</h2><p>But not all booleans are bad. Many popular libraries, such as <em>react-query</em>, <em>apollo</em> and <em>urql</em> use booleans in their state. An example implementation:</p><pre><code class="language-js">const [result] = useQuery();

if (result.isLoading) {
  return &lt;div&gt;Loading...&lt;/div&gt;;
}
</code></pre><p>The reason these are good booleans is that their underlying mechanism is based on an enum. Bad booleans represent state. Good booleans are derived from state:</p><pre><code class="language-js">let status: Status = &quot;loading&quot;;

// Derived from the status above
let isLoading = status === &quot;loading&quot;;
</code></pre><p>You can safely use this <code>isLoading</code> to display your loading spinner, happy in the knowledge that you&#x27;ve removed all impossible states.</p><h2>Addendum: Enums in Javascript</h2><p>A couple of folks in the comments are asking how we represent a state enum in Javascript. While the above code will work without typings, you can also represent enums as an object type.</p><pre><code class="language-ts">const statusEnum = {
  loading: &quot;loading&quot;,
  complete: &quot;complete&quot;,
  errored: &quot;errored&quot;,
};

let status = statusEnum.loading;

const makeFetch = async () =&gt; {
  status = statusEnum.loading;
  try {
    await fetch(&quot;/users&quot;);

    status = statusEnum.complete;
  } catch (e) {
    status = statusEnum.errored;
  }
};
</code></pre>]]>
      </content:encoded>
    </item>
    <item>
      <title>
        <![CDATA[Redux is half of a pattern (2/2)]]>
      </title>
      <link>https://stately.ai/blog/redux-is-half-of-a-pattern-22</link>
      <guid>https://stately.ai/blog/redux-is-half-of-a-pattern-22</guid>
      <pubDate>Fri, 22 May 2020 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Learn how Redux, and all other state management libraries, have one thing in common - they are all partial implementations of state machines - and how we can improve the way we model app state and logic.]]>
      </description>
      <content:encoded>
        <![CDATA[<p>I wrote a form library once.</p><p><em>Once.</em></p><p>It was called <a href="https://github.com/davidkpiano/react-redux-form">React Redux Form</a>, and using Redux for forms was a good idea, at the time (don&#x27;t use it). In fact, my library was written as a response to <a href="https://github.com/redux-form/redux-form">Redux Form</a>, and both libraries soon discovered that the idea of using a <em>single global store</em> to store all of your application state is a really, really bad idea.</p><p>When all of your forms live in one single store, state is easy to manage at first. And then, every single keypress starts to lag. It&#x27;s a terrible user experience.</p><p>So what do you do?</p><ul><li>Blur inputs</li><li>Add debounced updates</li><li>Memoize <em>everything</em></li><li>Optimize selectors everywhere</li><li>Make controlled components uncontrolled</li><li>Use <code>React.memo()</code> on components</li><li>Use <code>PureComponent</code> for good measure</li><li>Use Suspense (??)</li><li>etc. etc.</li></ul><p>In short, you go into panic mode and try to contain the spread of the global updates affecting every single connected component, even if those components don&#x27;t need to rerender.</p><p>Some of you have gotten really good at solving this, and have become expert &quot;selector, caching, and memoization&quot; developers. That&#x27;s fantastic.</p><p>But let&#x27;s examine if those tactics should even be necessary. What if all state <em>wasn&#x27;t</em> global?</p><div id="1241756566048694272"></div><h2>Local vs. global state</h2><p>The first of <a href="https://redux.js.org/introduction/three-principles">Redux&#x27;s three principles</a> is that there is essentially a <em>single source of truth</em> for your whole application state:</p><blockquote><p>The state of your whole application is stored in an object tree within a single store.</p><p><em>Source: <a href="https://redux.js.org/introduction/three-principles#single-source-of-truth">Redux&#x27;s three principles: single source of truth</a></em></p></blockquote><p>The primary reason for this is that it makes many things <em>easier</em>, such as sharing data, rehydrating state, &quot;time-travel debugging&quot;, etc. But it suffers from a fundamental disconnect: <em>there is no such thing as a single source of truth</em> in any non-trivial application. All applications, even front-end apps, are distributed at some level:</p><div id="1116019772238454784"></div><p>And, in a contradictory way, even the Redux Style Guide advises against putting the entire state of your application in a single store:</p><blockquote><p>[...] Instead, there should be a single place to find all values that you consider to be global and app-wide. Values that are &quot;local&quot; should generally be kept in the nearest UI component instead.</p><p><em>Source: <a href="https://redux.js.org/style-guide/style-guide/#evaluate-where-each-piece-of-state-should-live">Redux Style Guide</a></em></p></blockquote><p>Whenever something is done for the sole purpose of making something easy, it almost always makes some other use-case more difficult. Redux and its single-source-of-truth is no exception, as there are many problems that arise from fighting against the nature of front-end apps being &quot;distributed&quot; instead of an idealistic atomic, global unit:</p><ul><li>Multiple orthogonal concerns that need to be represented in the state somehow.</li></ul><p>This is &quot;solved&quot; by using <a href="https://redux.js.org/recipes/structuring-reducers/using-combinereducers"><code>combineReducers</code></a>.</p><ul><li>Multiple separate concerns that need to share data, communicate with each other, or are otherwise tangentially related.</li></ul><p>This is &quot;solved&quot; by <a href="https://redux.js.org/recipes/structuring-reducers/beyond-combinereducers">more complex, custom reducers</a> that orchestrate events through these otherwise separate reducers.</p><ul><li>Irrelevant state updates: when separate concerns are combined (using <code>combineReducers</code> or similar) into a single store, whenever any part of the state updates, the <em>entire</em> state is updated, and every &quot;connected&quot; component (every subscriber to the Redux store) is notified.</li></ul><p>This is &quot;solved&quot; by using <a href="https://redux.js.org/introduction/learning-resources#selectors">selectors</a>, and perhaps by using another library like <a href="https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/"><code>reselect</code></a> for memoized selectors.</p><p>I put &quot;solved&quot; in quotes because these are all solutions that are all but necessary due to problems that are caused solely by using a global, atomic store. In short, having a single global store is unrealistic, even for apps that are already using global stores. Whenever you use a 3rd-party component, or local state, or local storage, or query parameters, or a router, etc., you have already shattered the illusion of a single global store. App data is always distributed at some level, so the natural solution should be to embrace the distribution (by using local state) rather than fighting against it just for the sake of making some use-cases easier to develop in the short run.</p><h2>Acting differently</h2><p>So how can we address this global state problem? To answer that, we need to go back in time a little bit and take some inspiration from another old, well-established model: <a href="https://en.wikipedia.org/wiki/Actor_model">the actor model</a>.</p><p>The actor model is a surprisingly simple model that can be extended slightly beyond its original purpose (concurrent computation). In short, an actor is an entity that can do three things:</p><ul><li>It can receive messages (events)</li><li>It can change its state/behavior as a reaction to a received message, including spawning other actors</li><li>It can send messages to other actors</li></ul><p>If you thought &quot;hmm... so a Redux store is sort of an actor&quot;, congratulations, you already have a basic grasp of the model! A Redux store, which is based on some single combined-reducer thing:</p><ul><li>‚úÖ Can receive events</li><li>‚úÖ Changes its state (and thus its behavior, <a href="https://dev.to/davidkpiano/redux-is-half-of-a-pattern-1-2-1hd7">if you&#x27;re doing it right</a>) as a reaction to those events</li><li>‚ùå Can&#x27;t send messages to other stores (there&#x27;s only one store) or between reducers (dispatching only happens outside-in).</li></ul><p>It also can&#x27;t really spawn other &quot;actors&quot;, which makes the <a href="https://redux.js.org/advanced/async-actions">Reddit example in the official Redux advanced tutorial</a> more awkward than it needs to be:</p><pre><code class="language-js">function postsBySubreddit(state = {}, action) {
  switch (action.type) {
    case INVALIDATE_SUBREDDIT:
    case RECEIVE_POSTS:
    case REQUEST_POSTS:
      return Object.assign({}, state, {
        [action.subreddit]: posts(state[action.subreddit], action),
      });
    default:
      return state;
  }
}
</code></pre><blockquote><p><em>Source: <a href="https://redux.js.org/advanced/async-actions#reducersjs">https://redux.js.org/advanced/async-actions#reducersjs</a></em></p></blockquote><p>Let&#x27;s dissect what is happening here:</p><ol><li>We&#x27;re taking only the relevant slice of state we need (<code>state[action.subreddit]</code>), which should ideally be its own entity</li><li>We are determining what the next state of only this slice should be, via <code>posts(state[action.subreddit], action)</code></li><li>We are surgically replacing that slice with the updated slice, via <code>Object.assign(...)</code>.</li></ol><p>In other words, there is no way we can dispatch or forward an event directly to a specific &quot;entity&quot; (or <em>actor</em>); we only have a single actor and have to manually update only the relevant part of it. Also, every other reducer in <code>combineReducers(...)</code> will get the entity-specific event, and even if they don&#x27;t update, every single one of them will still be called for every single event. There&#x27;s no easy way to optimize that. A function that isn&#x27;t called is still much more optimal than a function that is called and ultimately does nothing (i.e., returns the same state), which happens most of the time in Redux.</p><h2>Reducers and actors</h2><p>So how do reducers and actors fit together? Simply put, a reducer describes the behavior of an individual actor:</p><ul><li>Events are sent to a reducer</li><li>A reducer&#x27;s state/behavior can change due to a received event</li><li>A reducer can spawn actors and/or send messages to other actors (via executed declarative actions)</li></ul><p>This isn&#x27;t a cutting-edge, groundbreaking model; in fact, you&#x27;ve probably been using the actor model (to some extent) without even knowing it! Consider a simple input component:</p><pre><code class="language-jsx">const MyInput = ({ onChange, disabled }) =&gt; {
  const [value, setValue] = useState(&quot;&quot;);

  return (
    &lt;input
      disabled={disabled}
      value={value}
      onChange={(e) =&gt; setValue(e.target.value)}
      onBlur={() =&gt; onChange(value)}
    /&gt;
  );
};
</code></pre><p>This component, in an implicit way, is sort of like an actor!</p><ul><li>It &quot;receives events&quot; using React&#x27;s slightly awkward parent-to-child communication mechanism - prop updates</li><li>It changes state/behavior when an event is &quot;received&quot;, such as when the <code>disabled</code> prop changes to <code>true</code> (which you can interpret as some event)</li><li>It can send events to other &quot;actors&quot;, such as sending a &quot;change&quot; event to the parent by calling the <code>onChange</code> callback (again, using React&#x27;s slightly awkward child-to-parent communication mechanism)</li><li>In theory, it can &quot;spawn&quot; other &quot;actors&quot; by rendering different components, each with their own local state.</li></ul><p>Reducers make the behavior and business logic more explicit, especially when &quot;implicit events&quot; become concrete, dispatched events:</p><pre><code class="language-jsx">const inputReducer = (state, event) =&gt; {
  /* ... */
};

const MyInput = ({ onChange, disabled }) =&gt; {
  const [state, dispatch] = useReducer(inputReducer, {
    value: &quot;&quot;,
    effects: [],
  });

  // Transform prop changes into events
  useEffect(() =&gt; {
    dispatch({ type: &quot;DISABLED&quot;, value: disabled });
  }, [disabled]);

  // Execute declarative effects
  useEffect(() =&gt; {
    state.effects.forEach((effect) =&gt; {
      if (effect.type === &quot;notifyChange&quot;) {
        // &quot;Send&quot; a message back up to the parent &quot;actor&quot;
        onChange(state.value);
      }
    });
  }, [state.effects]);

  return (
    &lt;input
      disabled={disabled}
      value={state.value}
      onChange={(e) =&gt;
        dispatch({
          type: &quot;CHANGE&quot;,
          value: e.target.value,
        })
      }
      onBlur={() =&gt; dispatch({ type: &quot;BLUR&quot; })}
    /&gt;
  );
};
</code></pre><h2>Multi-Redux?</h2><p>Again, one of Redux&#x27;s three main principles is that Redux exists in a single, global, atomic source of truth. All of the events are routed through that store, and the single huge state object is updated and permeates through all connected components, which use their selectors and memoization and other tricks to ensure that they are only updated when they need to be, especially when dealing with excessive, irrelevant state updates.</p><p>And using a single global store has worked pretty well when using Redux, right? Well... not exactly, to the point that there are entire libraries dedicated to providing the ability to use Redux on a more distributed level, e.g., for <a href="https://redux.js.org/introduction/ecosystem#component-state-and-encapsulation">component state and encapsulation</a>. It is possible to use Redux at a local component level, but that was not its main purpose, and the official <code>react-redux</code> integration does not naturally provide that ability.</p><h2>No Redux?</h2><p>There are other libraries that embrace the idea of &quot;state locality&quot;, such as <a href="https://mobx.js.org/README.html">MobX</a> and <a href="https://xstate.js.org/docs/">XState</a>. For React specifically, there is <a href="http://recoiljs.org/">Recoil</a> for &quot;distributed&quot; state and the built-in <a href="https://reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code> hook</a> that feels a lot like a local Redux, specifically for your component. For declarative effects, I created <a href="https://github.com/davidkpiano/useeffectreducer"><code>useEffectReducer</code></a> which looks and feels just like <code>useReducer</code>, but also gives you a way to manage effects.</p><p>For state that needs to be shared (not globally), you can use a pattern that is very similar to what React-Redux already uses, by making an object that can be subscribed to (i.e., &quot;listened&quot; to) and passed down through <a href="https://reactjs.org/docs/hooks-reference.html#usecontext">context</a>:</p><div id="1228700861024604160"></div><p>That will give you the best performance, as that &quot;subscribable&quot; object will seldom/never change. If that feels a bit boilerplatey for you and performance is not a huge concern, you can combine <code>useContext</code> and <code>useReducer</code> with not too much effort:</p><pre><code class="language-jsx">const CartContext = createContext();

const cartReducer = (state, event) =&gt; {
  // reducer logic
  // try using a state machine here! they&#x27;re pretty neat

  return state;
};

const initialCartState = {
  // ...
};

const CartContextProvider = ({ children }) =&gt; {
  const [state, dispatch] = useReducer(cartReducer, initialCartState);

  return (
    &lt;CartContext.Provider value={[state, dispatch]}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
};

export const useCartContext = () =&gt; {
  return useContext(CartContext);
};
</code></pre><p>And then use it in your components:</p><pre><code class="language-jsx">const CartView = () =&gt; {
  const [state, dispatch] = useCartContext();

  // ...
};
</code></pre><p>Not too bad, right? In general, this is not a problem that can be solved in Redux without going against-the-grain, since Redux is fundamentally a single, atomic global store.</p><h2>What do others think?</h2><p>I ran a non-scientific poll on Twitter to see where most app state lives, and how developers feel about it:</p><div id="1227615817640087553"></div><p><img src="https://dev-to-uploads.s3.amazonaws.com/i/lioo56gpviopcy2ccwqf.png" alt="Global vs. Local State poll"/></p><p>From this, I gather two things:</p><ul><li>Whether you distribute state locally, or contain all state in a single store, you will be able to accomplish app state requirements successfully.</li><li>However, more developers are discontent with the majority of app state being global instead of local, which also might hint to why the majority of developers are happy using local state instead.</li></ul><p>What do you think? Share your thoughts in the comments!</p><h2>Conclusion</h2><p>Thinking in terms of &quot;actors&quot;, in which your application is organized by lots of smaller actors that all talk to each other by passing messages/events to each other, can encourage separation of concerns and make you think differently about how state should be localized (distributed) and connected. My goal for this post is to help you realize that not <em>all</em> state needs to be global, and that other patterns (such as the Actor Model) exist for modeling distributed state and communication flow.</p><p>The Actor Model is not a panacea, though. If you&#x27;re not careful, you can end up having a spaghetti-like state management problem, where you have completely lost track of which actor is talking to another actor. Anti-patterns are present in any solution that you choose, so it helps to research best practices and actually model your app before you start coding.</p><p>If you want to learn more about the Actor Model, check out <a href="https://www.brianstorti.com/the-actor-model/">The Actor Model in 10 Minutes</a> by <a href="https://twitter.com/brianstorti">Brian Storti</a>, or any of these videos:</p><div id="ELwEdb_pD0k"></div><div id="Vg60lf92EkM"></div><p>Please keep in mind that this is post reflects my opinions based on what I&#x27;ve researched, and is in no way meant to be authoritative on the way you should do things. I want to make you <em>think</em>, and I hope that this post accomplished that goal. Thanks for reading!</p><p>If you enjoyed this post (or even if you didn&#x27;t and just want to hear more of my state management ramblings), <a href="https://www.stately.dev/">subscribe to the Stately Newsletter</a> for more content, thoughts, and discussion üì¨</p><div id="1237091703087079425"></div>]]>
      </content:encoded>
    </item>
    <item>
      <title>
        <![CDATA[Redux is half of a pattern (1/2)]]>
      </title>
      <link>https://stately.ai/blog/redux-is-half-of-a-pattern-12</link>
      <guid>https://stately.ai/blog/redux-is-half-of-a-pattern-12</guid>
      <pubDate>Mon, 20 Jan 2020 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[Learn how Redux, and all other state management libraries, have one thing in common - they are all partial implementations of state machines - and how we can improve the way we model app state and logic.]]>
      </description>
      <content:encoded>
        <![CDATA[<p>Redux is fantastic.</p><p>Some of you might disagree, so let me tell you why.</p><p>Over the last few years, Redux has popularized the idea of using message-passing (also known as <a href="https://en.wikipedia.org/wiki/Event-driven_programming">event-driven programming</a>) to manage application state. Instead of making arbitrary method calls to various class instances or mutating data structures, we now can think of state as being in a &quot;predictable container&quot; that only changes as a reaction to these &quot;events&quot;.</p><p>This simple idea and implementation is universal enough to be used with any framework (or no framework at all), and has inspired libraries for other popular frameworks such as:</p><ul><li><a href="https://vuex.vuejs.org/">Vuex</a> for Vue</li><li><a href="https://ngrx.io/">NgRx</a> for Angular</li></ul><p>However, Redux has recently come under scrutiny by some prominent developers in the web community:</p><div id="1191487232038883332"></div><div id="1195126928799227905"></div><p>If you don&#x27;t know these developers, they are the co-creators of Redux themselves. So why have Dan and Andrew, and many other developers, all but forsaken the use of Redux in applications?</p><p>The ideas and patterns in Redux appear sound and reasonable, and Redux is still used in many large-scale production apps today. However, it forces a certain architecture in your application:</p><div id="1025408731805184000"></div><p>As it turns out, this kind of single-atom immutable architecture is <em>not natural</em> nor does it represent how any software application works (nor should work) in the real-world.</p><p>Redux is an alternative implementation of Facebook&#x27;s <a href="https://facebook.github.io/flux">Flux &quot;pattern&quot;</a>. Many sticking points and hardships with Facebook&#x27;s implementation have led developers to seek out alternative, nicer, more developer-friendly APIs such as Redux, Alt, Reflux, Flummox, <a href="https://github.com/kriasoft/react-starter-kit/issues/22">and many more.</a>. Redux emerged as a <a href="https://facebook.github.io/flux/docs/related-libraries/#redux---alternative-state-management">clear winner</a>, and it is stated that Redux combines the ideas from:</p><ul><li><a href="https://www.wikiwand.com/en/Command_pattern">The Command pattern</a></li><li><a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a></li></ul><p>However, not even the Elm architecture is a standalone architecture/pattern, as it is based on fundamental patterns, whether developers know it or not:</p><blockquote><p>Rather than someone inventing it, early Elm programmers kept discovering the same basic patterns in their code. It was kind of spooky to see people ending up with well-architected code without planning ahead!</p></blockquote><div id="1202580315652448263"></div><p>In this post, I will highlight some of the reasons that Redux is <em>not</em> a standalone pattern by comparing it to a fundamental, well-established pattern: the <strong>finite state machine</strong>. This is not an arbitrary choice; every single application that we write is basically a state machine, whether we know it or not. The difference is that the state machines we write are implicitly defined.</p><p>I hope that some of these comparisons and differences will help you realize how some of the common pain points in Redux-driven applications materialize, and how you can use this existing pattern to help you craft a better state management architecture, whether you&#x27;re using Redux, another library, or no library at all.</p><h2>What is a finite state machine?</h2><p>(Taken from another article I wrote, <a href="https://medium.com/@DavidKPiano/the-facetime-bug-and-the-dangers-of-implicit-state-machines-a5f0f61bdaa2">The FaceTime Bug and the Dangers of Implicit State Machines</a>):</p><p>Wikipedia has a <a href="https://en.wikipedia.org/wiki/Finite-state_machine">useful but technical description</a> on what a finite state machine is. In essence, a finite state machine is a computational model centered around states, events, and transitions between states. To make it simpler, think of it this way:</p><ul><li>Any software you make can be described in a <strong>finite number of states</strong> (e.g., <code>idle</code>, <code>loading</code>, <code>success</code>, <code>error</code>)</li><li>You can only be in <strong>one</strong> of those states at any given time (e.g., you can‚Äôt be in the <code>success</code> and <code>error</code> states at the same time)</li><li>You always start at some <strong>initial state</strong> (e.g., <code>idle</code>)</li><li>You move from state to state, or <strong>transition</strong>, based on events (e.g., from the <code>idle</code> state, when the <code>LOAD</code> event occurs, you immediately transition to the <code>loading</code> state)</li></ul><p>It‚Äôs like the software that you‚Äôre used to writing, but with more explicit rules. You might have been used to writing <code>isLoading</code> or <code>isSuccess</code> as Boolean flags before, but state machines make it so that you‚Äôre not allowed to have <code>isLoading === true &amp;&amp; isSuccess === true</code> at the same time.</p><p>It also makes it <em>visually clear</em> that event handlers can only do one main thing: forward their events to a state machine. They‚Äôre not allowed to ‚Äúescape‚Äù the state machine and execute business logic, just like real-world physical devices: buttons on calculators or ATMs don‚Äôt actually do operations or execute actions; rather, they send &quot;signals&quot; to some central unit that manages (or <em>orchestrates</em>) state, and that unit decides what should happen when it receives that &quot;signal&quot;.</p><h2>What about state that is not finite?</h2><p>With state machines, especially <a href="https://en.wikipedia.org/wiki/UML_state_machine">UML state machines (a.k.a. statecharts)</a>, &quot;state&quot; refers to something different than the data that doesn&#x27;t fit neatly into finite states, but both &quot;state&quot; and what&#x27;s known as <a href="https://en.wikipedia.org/wiki/UML_state_machine#Extended_states">&quot;extended state&quot;</a> work together.</p><p>For example, let&#x27;s consider water üö∞. It can fit into one of four phases, and we consider these the <em>states</em> of water:</p><ul><li><code>liquid</code></li><li><code>solid</code> (e.g., ice, frost)</li><li><code>gas</code> (e.g., vapor, steam)</li><li><code>plasma</code></li></ul><p><a href="https://www.uml-diagrams.org/examples/water-phase-uml-state-machine-diagram-example.html"><img src="https://www.uml-diagrams.org/examples/state-machine-example-water.png" alt="Water phase UML state machine diagram"/></a></p><blockquote><p>Water phase UML state machine diagram from <a href="https://www.uml-diagrams.org/examples/water-phase-uml-state-machine-diagram-example.html">uml-diagrams.com</a></p></blockquote><p>However, the temperature of water is a <em>continuous</em> measurement, not a discrete one, and it can&#x27;t be represented in a finite way. Despite this, water temperature can be represented alongside the finite state of water, e.g.:</p><ul><li><code>liquid</code> where <code>temperature === 90</code> (celsius)</li><li><code>solid</code> where <code>temperature === -5</code></li><li><code>gas</code> where <code>temperature === 500</code></li></ul><p>There&#x27;s many ways to represent the combination of finite and extended state in your application. For the water example, I would personally call the finite state <code>value</code> (as in the &quot;finite state value&quot;) and the extended state <code>context</code> (as in &quot;<em>contextual</em> data&quot;):</p><pre><code class="language-js">const waterState = {
  value: &quot;liquid&quot;, // finite state
  context: {
    // extended state
    temperature: 90,
  },
};
</code></pre><p>But you&#x27;re free to represent it in other ways:</p><pre><code class="language-js">const waterState = {
  phase: &quot;liquid&quot;, // finite state
  data: {
    // extended state
    temperature: 90,
  },
};

// or...

const waterState = {
  status: &quot;liquid&quot;, // finite state
  temperature: 90, // anything not &#x27;status&#x27; is extended state
};
</code></pre><p>The key point is that there is a clear distinction between <strong>finite</strong> and <strong>extended</strong> state, and there is logic that prevents the application from reaching an <em>impossible state</em>, e.g.:</p><pre><code class="language-js">const waterState = {
  isLiquid: true,
  isGas: true, // üö± Water can&#x27;t be both liquid and gas simultaneously!
  temperature: -50, // ‚ùÑÔ∏è This is ice!! What&#x27;s going on??
};
</code></pre><p>And we can extend these examples to realistic code, such as changing this:</p><pre><code class="language-js">const userState = {
  isLoading: true,
  isSuccess: false,
  user: null,
  error: null,
};
</code></pre><p>To something like this:</p><pre><code class="language-js">const userState = {
  status: &quot;loading&quot;, // or &#x27;idle&#x27; or &#x27;error&#x27; or &#x27;success&#x27;
  user: null,
  error: null,
};
</code></pre><p>This prevents impossible states like <code>userState.isLoading === true</code> and <code>userState.isSuccess === true</code> happening simultaneously.</p><h2>How does Redux compare to a finite state machine?</h2><p>The reason I&#x27;m comparing Redux to a state machine is because, from a birds-eye view, their state management models look pretty similar. For Redux:</p><blockquote><p><code>state</code> + <code>action</code> = <code>newState</code></p></blockquote><p>For state machines:</p><blockquote><p><code>state</code> + <code>event</code> = <code>newState</code> + <code>effects</code></p></blockquote><p>In code, these can even be represented the same way, by using a <a href="https://redux.js.org/basics/reducers/">reducer</a>:</p><pre><code class="language-js">function userReducer(state, event) {
  // Return the next state, which is
  // determined based on the current `state`
  // and the received `event` object

  // This nextState may contain a &quot;finite&quot;
  // state value, as well as &quot;extended&quot;
  // state values.

  // It may also contain side-effects
  // to be executed by some interpreter.
  return nextState;
}
</code></pre><p>There are already some subtle differences, such as &quot;action&quot; vs. &quot;event&quot; or how extended state machines model side-effects (<a href="https://en.wikipedia.org/wiki/UML_state_machine#Actions_and_transitions">they do</a>). Dan Abramov even recognizes some of the differences:</p><div id="1064661742188417029"></div><p>A reducer can be used to implement a finite state machine, but most reducers are <em>not</em> modeled as finite state machines. Let&#x27;s change that by learning some of the differences between Redux and state machines.</p><h2>Difference: finite &amp; extended states</h2><p>Typically, a Redux reducer&#x27;s state will not make a clear distinction between &quot;finite&quot; and &quot;extended&quot; states, as previously mentioned above. This is an important concept in state machines: an application is always in <em>exactly one</em> of a finite number of &quot;states&quot;, and the rest of its data is represented as its extended state.</p><p>Finite states can be introduced to a reducer by making an explicit property that represents exactly one of the many possible states:</p><pre><code class="language-js">const initialUserState = {
  status: &quot;idle&quot;, // explicit finite state
  user: null,
  error: null,
};
</code></pre><p>What&#x27;s great about this is that, if you&#x27;re using TypeScript, you can take advantage of using <a href="https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html">discriminated unions</a> to make impossible states impossible:</p><pre><code class="language-js">interface User {
  name: string;
  avatar: string;
}

type UserState =
  | { status: &quot;idle&quot;, user: null, error: null }
  | { status: &quot;loading&quot;, user: null, error: null }
  | { status: &quot;success&quot;, user: User, error: null }
  | { status: &quot;failure&quot;, user: null, error: string };
</code></pre><h2>Difference: events vs. actions</h2><p>In <a href="https://en.wikipedia.org/wiki/UML_state_machine#Actions_and_transitions">state machine terminology</a>, an &quot;action&quot; is a side-effect that occurs as the result of a transition:</p><blockquote><p>When an event instance is dispatched, the state machine responds by <strong>performing actions</strong>, such as changing a variable, performing I/O, invoking a function, generating another event instance, or changing to another state.</p></blockquote><p>This isn&#x27;t the only reason that using the term &quot;action&quot; to describe something that causes a state transition is confusing; &quot;action&quot; also suggests something that needs to be done (i.e., a command), rather than something that just happened (i.e., an event).</p><p>So keep the following terminology in mind when we talk about state machines:</p><ul><li>An <strong>event</strong> describes something that occurred. Events trigger state transitions.</li><li>An <strong>action</strong> describes a side-effect that should occur as a <em>response</em> to a state transition.</li></ul><p>The <a href="https://redux.js.org/style-guide/style-guide/">Redux style guide</a> also directly suggests modeling actions as events:</p><blockquote><p>However, we recommend trying to treat actions more as &quot;describing events that occurred&quot;, rather than &quot;setters&quot;. Treating actions as &quot;events&quot; generally leads to more meaningful action names, fewer total actions being dispatched, and a more meaningful action log history.</p><p><em>Source: <a href="https://redux.js.org/style-guide/style-guide/#model-actions-as-events-not-setters">Redux style guide: Model actions as events, not setters</a></em></p></blockquote><p>When the word &quot;event&quot; is used in this article, that has the same meaning as a conventional Redux action object. For side-effects, the word &quot;effect&quot; will be used.</p><div id="1218698479872040960"></div><h2>Difference: explicit transitions</h2><p>Another fundamental part of how state machines work are <strong>transitions</strong>. A transition describes how one finite state transitions to another finite state due to an event. This can be represented using boxes and arrows:</p><p><img src="https://thepracticaldev.s3.amazonaws.com/i/9cerj02qg66buqdmjrmq.png" alt="State machine describing login flow"/></p><p>This diagram makes it clear that it&#x27;s impossible to transition directly from, e.g., <code>idle</code> to <code>success</code> or from <code>success</code> to <code>error</code>. There are clear sequences of events that need to occur to transition from one state to another.</p><p>However, the way that developers tend to model reducers is by determining the next state solely on the received event:</p><pre><code class="language-js">function userReducer(state, event) {
  switch (event.type) {
    case &quot;FETCH&quot;:
    // go to some &#x27;loading&#x27; state
    case &quot;RESOLVE&quot;:
    // go to some &#x27;success&#x27; state
    case &quot;REJECT&quot;:
    // go to some &#x27;error&#x27; state
    default:
      return state;
  }
}
</code></pre><p>The problem with managing state this way is that it does not prevent <em>impossible transitions</em>. Have you ever seen a screen that briefly displays an error, and then shows some success view? If you haven&#x27;t, browse <a href="https://reddit.com">Reddit</a>, and do the following steps:</p><ol><li>Search for anything.</li><li>Click on the &quot;Posts&quot; tab while the search is happening.</li><li>Say &quot;aha!&quot; and wait a couple seconds.</li></ol><p>In step 3, you&#x27;ll probably see something like this (visible at the time of publishing this article):</p><p><img src="https://i.imgur.com/NJnApBV.gif" alt="Reddit bug showing no search results"/></p><p>After a couple seconds, this unexpected view will disappear and you will finally see search results. This bug has been present for a while, and even though it&#x27;s innocuous, it&#x27;s not the best user experience, and it can definitely be considered faulty logic.</p><p>However it is implemented (Reddit <em>does</em> use Redux...), something is definitely wrong: <em>an impossible state transition happened</em>. It makes absolutely no sense to transition directly from the &quot;error&quot; view to the &quot;success&quot; view, and in this case, the user shouldn&#x27;t see an &quot;error&quot; view anyway because it&#x27;s not an error; it&#x27;s still loading!</p><p>You might be looking through your existing Redux reducers and realize where this potential bug may surface, because by basing state transitions only on events, these impossible transitions become possible to occur. Sprinkling if-statements all over your reducer might alleviate the symptoms of this:</p><pre><code class="language-js">function userReducer(state, event) {
  switch (event.type) {
    case &quot;FETCH&quot;:
      if (state.status !== &quot;loading&quot;) {
        // go to some &#x27;loading&#x27; state...
        // but ONLY if we&#x27;re not already loading
      }

    // ...
  }
}
</code></pre><p>But that only makes your state logic harder to follow because the state transitions are <em>not explicit</em>. Even though it might be a little more verbose, it&#x27;s better to determine the next state based on both the current finite state and the event, rather than just on the event:</p><pre><code class="language-js">function userReducer(state, event) {
  switch (state.status) {
    case &quot;idle&quot;:
      switch (event.type) {
        case &quot;FETCH&quot;:
        // go to some &#x27;loading&#x27; state

        // ...
      }

    // ...
  }
}
</code></pre><p>You can even split this up into individual &quot;finite state&quot; reducers, to make things cleaner:</p><pre><code class="language-js">function idleUserReducer(state, event) {
  switch (event.type) {
    case &#x27;FETCH&#x27;:
      // go to some &#x27;loading&#x27; state

      // ...
    }
    default:
      return state;
  }
}

function userReducer(state, event) {
  switch (state.status) {
    case &#x27;idle&#x27;:
      return idleUserReducer(state, event);
    // ...
  }
}
</code></pre><p>But don&#x27;t just take my word for it. The Redux style guide also strongly recommends treating your reducers as state machines:</p><blockquote><p>[...] treat reducers as &quot;state machines&quot;, where the combination of both the current state and the dispatched action determines whether a new state value is actually calculated, not just the action itself unconditionally.</p><p><em>Source: <a href="https://redux.js.org/style-guide/style-guide/#treat-reducers-as-state-machines">Redux style guide: treat reducers as state machines</a></em></p></blockquote><p>I also talk about this idea in length in my post: <a href="https://dev.to/davidkpiano/no-disabling-a-button-is-not-app-logic-598i">No, disabling a button is not app logic.</a></p><h2>Difference: declarative effects</h2><p>If you look at Redux in isolation, its strategy for managing and executing side-effects is this:</p><blockquote><p>¬Ø\_(„ÉÑ)_/¬Ø</p></blockquote><p>That&#x27;s right; Redux has no built-in way of handling side-effects. In any non-trivial application, you <em>will</em> have side-effects if you want to do anything useful, such as make a network request or kick off some sort of async process. Importantly enough, side-effects should <em>not</em> be considered an afterthought; they should be treated as a first-class citizen and uncompromisingly represented in your application logic.</p><p>Unfortunately, with Redux, they are, and the only solution is to use <a href="https://redux.js.org/advanced/middleware">middleware</a>, which is inexplicably an advanced topic, despite being required for any non-trivial app logic:</p><blockquote><p>Without middleware, Redux store only supports synchronous data flow.</p><p><em>Source: <a href="https://redux.js.org/advanced/async-flow">Redux docs: Async Flow</a></em></p></blockquote><p>With extended/UML state machines (also known as statecharts), these side-effects are known as <strong>actions</strong> (and will be referred to as actions for the rest of this post) and are declaratively modeled. Actions are the direct result of a transition:</p><blockquote><p>When an event instance is dispatched, the state machine responds by <strong>performing actions</strong>, such as changing a variable, performing I/O, invoking a function, generating another event instance, or changing to another state.</p><p>_Source: <a href="https://en.wikipedia.org/wiki/UML_state_machine#Actions_and_transitions">(Wikipedia) UML State Machine: Actions and Transitions</a></p></blockquote><p>This means that when an event changes state, actions (effects) may be executed as a result, even if the state stays the same (known as a &quot;self-transition&quot;). Just like Newton said:</p><blockquote><p>For every action, there is an equal and opposite reaction.</p><p><em>Source: Newton&#x27;s Third Law of Motion</em></p></blockquote><p>Actions <em>never</em> occur spontaneously, without cause; not in software, not in hardware, not in real life, never. There is <em>always</em> a cause for an action to occur, and with state machines, that cause is a state transition, due to a received event.</p><p>Statecharts distinguish how actions are determined in three possible ways:</p><ul><li><strong>Entry actions</strong> are effects that are executed whenever a specific finite state is entered</li><li><strong>Exit actions</strong> are effects that are executed whenever a specific finite state is exited</li><li><strong>Transition actions</strong> are effects that are executed whenever a specific transition between two finite states is taken.</li></ul><p>Fun fact: this is why statecharts are said to have the characteristic of both <a href="https://en.wikipedia.org/wiki/Mealy_machine">Mealy machines</a> and <a href="https://en.wikipedia.org/wiki/Moore_machine">Moore machines</a>:</p><ul><li>With Mealy machines, &quot;output&quot; (actions) depends on the state and the event (transition actions)</li><li>With Moore machines, &quot;output&quot; (actions) depends on just the state (entry &amp; exit actions)</li></ul><p>The original philosophy of Redux is that it did not want to be opinionated on how these side-effects are executed, which is why middleware such as <a href="https://github.com/reduxjs/redux-thunk">redux-thunk</a> and <a href="https://github.com/redux-utilities/redux-promise">redux-promise</a> exist. These libraries work around the fact that Redux is side-effect-agnostic by having third-party, use-case specific &quot;solutions&quot; for handling different types of effects.</p><p>So how can this be solved? It may seem weird, but just like you can use a property to specify finite state, you can also use a property to specify <em>actions that should be executed</em> in a declarative way:</p><pre><code class="language-js">// ...
case &#x27;FETCH&#x27;:
  return {
    ...state,

    // finite state
    status: &#x27;loading&#x27;,

    // actions (effects) to execute
    actions: [
      { type: &#x27;fetchUser&#x27;, id: 42 }
    ]
  }
// ...
</code></pre><p>Now, your reducer will return useful information that answers the question, &quot;what side-effects (actions) should be executed as a result of this state transition?&quot; The answer is clear and colocated right in your app state: read the <code>actions</code> property for a declarative description of the actions to be executed, and execute them:</p><pre><code class="language-js">// pretend the state came from a Redux React hook
const { actions } = state;

useEffect(() =&gt; {
  actions.forEach((action) =&gt; {
    if (action.type === &quot;fetchUser&quot;) {
      fetch(`/api/user/${action.id}`)
        .then((res) =&gt; res.json())
        .then((data) =&gt; {
          dispatch({ type: &quot;RESOLVE&quot;, user: data });
        });
    }
    // ... etc. for other action implementations
  });
}, [actions]);
</code></pre><p>Having side-effects modeled declaratively in some <code>state.actions</code> property (or similar) has some great benefits, such as in predicting/testing or being able to trace when actions will or have been executed, as well as being able to customize the implementation details of executing those actions. For instance, the <code>fetchUser</code> action can be changed to read from a cache instead, all without changing any of the logic in the reducer.</p><h2>Difference: sync vs. async data flow</h2><p>The fact is that middleware is indirection. It fragments your application logic by having it present in multiple places (the reducers and the middleware) without a clear, cohesive understanding of how they work together. Furthermore, it makes some use-cases easier but others much more difficult. For example: take this example from the <a href="https://redux.js.org/advanced/example-reddit-api">Redux advanced tutorial</a>, which uses <code>redux-thunk</code> to allow dispatching a &quot;thunk&quot; for making an async request:</p><pre><code class="language-js">function fetchPosts(subreddit) {
  return (dispatch) =&gt; {
    dispatch(requestPosts(subreddit));
    return fetch(`https://www.reddit.com/r/${subreddit}.json`)
      .then((response) =&gt; response.json())
      .then((json) =&gt; dispatch(receivePosts(subreddit, json)));
  };
}
</code></pre><p>Now ask yourself: <em>how can I cancel this request?</em> With <code>redux-thunk</code>, it simply isn&#x27;t possible. And if your answer is to &quot;choose a different middleware&quot;, you just validated the previous point. Modeling logic should not be a question of which middleware you choose, and middleware shouldn&#x27;t even be part of the state modeling process.</p><p>As previously mentioned, the only way to model async data flow with Redux is by using middleware. And with all the possible use-cases, from thunks to Promises to sagas (generators) to epics (observables) and more, the ecosystem has plenty of different solutions for these. But the ideal number of solutions is <em>one</em>: the solution provided by the pattern in use.</p><p>Alright, so how do state machines solve the async data flow problem?</p><p><em>They don&#x27;t.</em></p><p>To clarify, state machines do not distinguish between sync and async data flows, because there is no difference. This is such an important realization to make, because not only does it simplify the idea of data flow, but it also models how things work in real life:</p><ul><li>A state transition (triggered by a received event) always occurs in &quot;zero-time&quot;; that is, states synchronously transition.</li><li>Events can be received at any time.</li></ul><p>There is no such thing as an asynchronous transition. For example, modeling data fetching doesn&#x27;t look like this:</p><pre><code>idle . . . . . . . . . . . . success
</code></pre><p>Instead, it looks like this:</p><pre><code class="language-html">idle --(FETCH)--&gt; loading --(RESOLVE)--&gt; success
</code></pre><p>Everything is the result of some event triggering a state transition. Middleware obscures this fact. If you&#x27;re curious how async cancellation can be handled in a synchronous state transition manner, here&#x27;s a couple of guiding points for a potential implementation:</p><ul><li>A cancellation intent is an <em>event</em> (e.g., <code>{ type: &#x27;CANCEL&#x27; }</code>)</li><li>Cancelling an in-flight request is an <em>action</em> (i.e., side-effect)</li><li>&quot;Canceled&quot; is a state, whether it&#x27;s a specific state (e.g., <code>canceled</code>) or a state where a request shouldn&#x27;t be active (e.g., <code>idle</code>)</li></ul><h2>To be continued</h2><p>It is possible to model application state in Redux to be more like a finite state machine, and it is good to do so for many reasons. The applications that we write have different modes, or &quot;behaviors&quot;, that vary depending on which &quot;state&quot; it&#x27;s in. Before, this state might have been implicit. But now, with finite states, you can group behavior by these finite states (such as <code>idle</code>, <code>loading</code>, <code>success</code>, etc.), which makes the overall app logic much more clear, and prevents the app from getting stuck in an impossible state.</p><p>Finite states also make clear what events can do, depending on which state it&#x27;s in, as well as what all the possible states are in an application. Additionally, they can map one-to-one to views in user interfaces.</p><p>But most importantly, state machines are present in all of the software that you write, and they have been for over half a century. Making finite state machines explicit brings clarity and robustness to complex app logic, and it is possible to implement them in any libraries that you use (or even no library at all).</p><p>In the next post, we&#x27;ll talk about how the Redux atomic global store is also half of a pattern, the challenges it presents, and how it compares to another well-known model of computation (the Actor model).</p>]]>
      </content:encoded>
    </item>
  </channel>
</rss>